<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>关爱颈椎成长协会</title>
    <link>https://ningoy.github.io/</link>
    <atom:link href="/ningoy.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Wed, 16 Jun 2021 10:39:03 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Tmux 会话(Session)/窗口(Window) 重命名快捷键汇总</title>
      <link>https://ningoy.github.io/2021/06/16/Tmux-%E4%BC%9A%E8%AF%9D-Session-%E7%AA%97%E5%8F%A3-Window-%E9%87%8D%E5%91%BD%E5%90%8D%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%B1%87%E6%80%BB/</link>
      <guid>https://ningoy.github.io/2021/06/16/Tmux-%E4%BC%9A%E8%AF%9D-Session-%E7%AA%97%E5%8F%A3-Window-%E9%87%8D%E5%91%BD%E5%90%8D%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%B1%87%E6%80%BB/</guid>
      <pubDate>Wed, 16 Jun 2021 10:28:44 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;会话session重命名&quot;&gt;会话（Session）重命名&lt;/h2&gt;
&lt;p&gt;使用快捷键重命名：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Ctrl + x, $&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用指令重命名，按快捷键进入指令模式&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Ctrl + x, 
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="会话session重命名">会话（Session）重命名</h2><p>使用快捷键重命名：</p><p><code>Ctrl + x, $</code></p><p>使用指令重命名，按快捷键进入指令模式</p><p><code>Ctrl + x, :</code></p><p>输入下述指令，指定当前会话名称和新的会话名称</p><p><code>rename-session [-t current-name] [new-name]</code></p><h2 id="窗口windows重命名">窗口（Windows）重命名</h2><p>使用快捷键来重命名</p><p><code>Ctrl + x, ,</code></p><p>使用指令重命名，类似上面提到的进入命令模式</p><p><code>Ctrl + x, :</code></p><p>输入窗口重命名指令：</p><p><code>rename-window [-t current-name] [new-name]</code></p>]]></content:encoded>
      
      <comments>https://ningoy.github.io/2021/06/16/Tmux-%E4%BC%9A%E8%AF%9D-Session-%E7%AA%97%E5%8F%A3-Window-%E9%87%8D%E5%91%BD%E5%90%8D%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%B1%87%E6%80%BB/#disqus_thread</comments>
    </item>
    
    <item>
      <title></title>
      <link>https://ningoy.github.io/2021/06/07/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%96%B9%E6%B3%95-%E6%A6%82%E7%8E%87%E7%BC%96%E7%A8%8B%E4%B8%8E%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%8E%A8%E6%96%AD/</link>
      <guid>https://ningoy.github.io/2021/06/07/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%96%B9%E6%B3%95-%E6%A6%82%E7%8E%87%E7%BC%96%E7%A8%8B%E4%B8%8E%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%8E%A8%E6%96%AD/</guid>
      <pubDate>Mon, 07 Jun 2021 02:26:58 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;简单来说，贝叶斯推断就是通过新得到的证据不断更新你的信念。&lt;/p&gt;
&lt;p&gt;在贝叶斯的世界观中，概率是被解释为我们对一件事情发生的相信程度，换句话说，这表明了我们对此事件发生的信心。&lt;/p&gt;
&lt;p&gt;频率学派眼中的概率是事件在长时间内发生的频率，比如飞机事故的概率指的是长期
        
      
      </description>
      
      <content:encoded><![CDATA[<p>简单来说，贝叶斯推断就是通过新得到的证据不断更新你的信念。</p><p>在贝叶斯的世界观中，概率是被解释为我们对一件事情发生的相信程度，换句话说，这表明了我们对此事件发生的信心。</p><p>频率学派眼中的概率是事件在长时间内发生的频率，比如飞机事故的概率指的是长期来看飞机事故的频率值。但是对某些没有长期频率的事件来说，这样解释是难以理解的。比如竞选时，某位候选人获选的概率，实际上这次竞选在现实中只会发生一次。而贝叶斯学派把概率解释为对事件发生的信心，如果概率为0则表示完全确定此事一定不会发生。</p><p>我们永远只能了解部分的真相，但可以不断收集证据来完善我们对事物的观念。</p><p>贝叶斯公式 <span class="math display">\[P(A|X) = \frac{P(X|A)P(A)}{P(X)}\]</span></p><p><span class="math display">\[\begin{align}P(X) &amp; = P(X\,and\,A) + P(X\,and\,~A)\\[3pt]&amp; = P(X|A)P(A) + P(X|~A)P(~A)\end{align}\]</span></p>]]></content:encoded>
      
      <comments>https://ningoy.github.io/2021/06/07/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%96%B9%E6%B3%95-%E6%A6%82%E7%8E%87%E7%BC%96%E7%A8%8B%E4%B8%8E%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%8E%A8%E6%96%AD/#disqus_thread</comments>
    </item>
    
    <item>
      <title>使用ARIMA模型进行时间序列分析</title>
      <link>https://ningoy.github.io/2021/06/04/%E4%BD%BF%E7%94%A8ARIMA%E6%A8%A1%E5%9E%8B%E8%BF%9B%E8%A1%8C%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E5%88%86%E6%9E%90/</link>
      <guid>https://ningoy.github.io/2021/06/04/%E4%BD%BF%E7%94%A8ARIMA%E6%A8%A1%E5%9E%8B%E8%BF%9B%E8%A1%8C%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E5%88%86%E6%9E%90/</guid>
      <pubDate>Fri, 04 Jun 2021 09:54:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;arima模型&quot;&gt;ARIMA模型&lt;/h1&gt;
&lt;p&gt;ARIMA模型，自回归移动平均模型（ARIMA，Autoregressive Integrated Moving Average Model），是统计模型中最常见的一种用来进行时间序列预测的模型，旨在描绘数据的自
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="arima模型">ARIMA模型</h1><p>ARIMA模型，自回归移动平均模型（ARIMA，Autoregressive Integrated Moving Average Model），是统计模型中最常见的一种用来进行时间序列预测的模型，旨在描绘数据的自回归性（autocorrelations）。如果观测值并非彼此独立，一个观测值可能会在i个时间单位后与另一个观测值相关，形成一种称为自相关的关系。自相关可以削减基于时间的预测模型（例如时间序列图）的准确性，并导致数据的错误解释。</p><p>在引入ARIMA模型之前，我们需要先讨论平稳性（stationarity）和差分时间序列（differencing time series）的相关知识。</p><h2 id="平稳性和差分">平稳性和差分</h2><p>平稳的时间序列的性质不随观测时间的变化而变化。因此具有趋势或季节性的时间序列不是平稳时间序列——趋势和季节性使得时间序列在不同时段呈现不同特质。与他们相反，白噪声序列（white noise series）则是平稳的——不管观测的时间如何变化，它看起来都应该是一样的。</p><p>在判断平稳性上，下面这个例子容易让人混淆：如果一个循环变化的时间序列没有趋势和季节性，那么它仍然是平稳的。这是因为这些循环变化并没有一个固定的周期，因此在进行观测之前我们无法知道循环变化的峰值和谷值会出现在哪个位置。</p><p>一般而言，一个平稳的时间序列从长期来看不存在可预测的特征。它的时间曲线图（time plots）反映出这个序列近似于水平（尽管可能存在一些周期性的变化）并保持固定的方差。</p><figure><img src="http://wxbfans-ink.oss-cn-beijing.aliyuncs.com/img/stationary-1.png?x-oss-process=PicGo" alt="图中的时间序列有哪些是平稳的？（a）连续292天的谷歌股价; （b）连续292天谷歌股价的每日变化量; （c）美国各年的罢工总次数; （d）美国独立家庭住宅的每月价格; （e）按不变美元计算的美国的鸡蛋价格; （e）每月在澳大利亚维多利亚州被屠宰的猪的数量; （g）每年在加拿大西北的麦肯齐河停留的猞猁数量; （h）澳大利亚每月啤酒产量; （i）澳大利亚每月发电量"><figcaption aria-hidden="true">图中的时间序列有哪些是平稳的？（a）连续292天的谷歌股价; （b）连续292天谷歌股价的每日变化量; （c）美国各年的罢工总次数; （d）美国独立家庭住宅的每月价格; （e）按不变美元计算的美国的鸡蛋价格; （e）每月在澳大利亚维多利亚州被屠宰的猪的数量; （g）每年在加拿大西北的麦肯齐河停留的猞猁数量; （h）澳大利亚每月啤酒产量; （i）澳大利亚每月发电量</figcaption></figure><blockquote><p>图 8.1: 图中的时间序列有哪些是平稳的？（a）连续292天的谷歌股价; （b）连续292天谷歌股价的每日变化量; （c）美国各年的罢工总次数; （d）美国独立家庭住宅的每月价格; （e）按不变美元计算的美国的鸡蛋价格; （e）每月在澳大利亚维多利亚州被屠宰的猪的数量; （g）每年在加拿大西北的麦肯齐河停留的猞猁数量; （h）澳大利亚每月啤酒产量; （i）澳大利亚每月发电量</p></blockquote><p>考虑图<a href="http://wxbfans-ink.oss-cn-beijing.aliyuncs.com/img/stationary-1.png?x-oss-process=PicGo" target="_blank" rel="noopener">8.1</a>中的九个时间序列，其中有哪些是平稳的时间序列？</p><p>显然存在季节性的序列（d）、（h）和（i）可以被排除。存在趋势的序列（a）、（c）、（e）、（f）和（i）也应该被排除，除此之外，序列（i）的方差随时间增大，也不符合平稳时间序列的性质。用上述方法排除后，剩下的（b）和（g）是平稳时间序列。</p><p>序列（g）的循环变化让它第一眼看上去不太平稳，但是这种变化其实是不定期的——当猞猁的数量超过食物承载的上限时，它们会停止繁殖从而使得数量回落到非常低的水平，之后食物来源的再生使得猞猁数量重新增长，周而复始。从长期来看，这种循环的时间点是不能预测的，因此序列（g）是平稳的。</p><h3 id="差分">差分</h3><p>在图 <a href="http://wxbfans-ink.oss-cn-beijing.aliyuncs.com/img/stationary-1.png?x-oss-process=PicGo" target="_blank" rel="noopener">8.1</a>中，我们注意到（a）中谷歌股价数并不平稳，但（b）中谷歌股价每天的变化量则是平稳的。这向我们展示了一种让非平稳时间序列变平稳的方法——计算相邻观测值之间的差值，这种方法被称为<strong>差分</strong>。</p><p>诸如对数变换的变换方法可用于平稳化（stabilize）时间序列的方差。差分则可以通过去除时间序列中的一些变化特征来平稳化它的均值，并因此消除（或减小）时间序列的趋势和季节性。</p><p>和时间曲线图一样，自相关图（ACF图）也能帮助我们识别非平稳时间序列。 对于一个平稳时间序列，自相关系数（ACF）会快速的下降到接近 0 的水平，然而非平稳时间序列的自相关系数会下降的比较缓慢。同样的，非平稳时间序列的 <span class="math inline">\(r_1\)</span> 通常非常大并且为正值。</p><p><img src="https://wxbfans-ink.oss-cn-beijing.aliyuncs.com/img/20210606013141.png?x-oss-process=PicGo" alt="谷歌股价（左图）和谷歌股价的每日变化（右图）的自相关系数。" style="zoom:67%;"></p><blockquote><p>图 8.2: 谷歌股价（左图）和谷歌股价的每日变化（右图）的自相关系数。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> yfinance <span class="keyword">as</span> yf</span><br><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line">goog = yf.download(<span class="string">"GOOG"</span>, start=<span class="string">"2013-01-01"</span>, end=<span class="string">"2013-12-06"</span>)</span><br><span class="line">sm.stats.acorr_ljungbox(goog[<span class="string">'Close'</span>] - goog[<span class="string">'Open'</span>], lags=[<span class="number">10</span>], return_df=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># lb_statlb_pvalue</span></span><br><span class="line"><span class="comment"># 1010.4988180.397872</span></span><br></pre></td></tr></table></figure><p>差分后的谷歌股价的自相关图看起来像白噪声序列。所有自回归系数都在95%的置信度以内，并且 Ljung-Box 检验中 <span class="math inline">\(Q^*\)</span> 统计量的<em>p</em>值为 0.355 (for <span class="math inline">\(h=10\)</span>)。这反映出谷歌股价的<em>每日变化</em>在本质上是一个与过去时间无关的随机值。</p><h3 id="随机游走模型">随机游走模型</h3><p>差分序列是指原序列的连续观测值之间的<em>变化值</em>组成的时间序列，它可以被表示为： <span class="math display">\[y&#39;_t = y_t - y_{t-1}.\]</span> 差分序列的长度为 <span class="math inline">\(T-1\)</span>，因为<span class="math inline">\(t=1\)</span>时，公式中的差值无法计算。</p><p>当差分序列是白噪声时，原序列的模型可以表示为： <span class="math display">\[y_t - y_{t-1} = \varepsilon_t,\]</span> 这里的<span class="math inline">\(\varepsilon_t\)</span>为白噪声。调整上式，即可得到“随机游走”模型： <span class="math display">\[y_t = y_{t-1} + \varepsilon_t.\]</span> 随机游走模型在非平稳时间序列数据中应用广泛，特别是金融和经济数据。典型的随机游走通常具有以下特征：</p><ul><li>长期的明显上升或下降趋势。</li><li>游走方向上突然的、不能预测的变化。</li></ul><p>由于未来变化是不可预测的，随机游走模型的预测值为上一次观测值，并且其上升和下降的可能性相同。因此，随机游走模型适用于朴素（naive）的预测。</p><p>通过稍许改进，我们可以让差值均值不为零。从而： <span class="math display">\[y_t - y_{t-1} = c + \varepsilon_t\quad\text{or}\quad {y_t = c + y_{t-1} + \varepsilon_t}\: .\]</span> <span class="math inline">\(c\)</span>值是连续观测值变化的平均值。如果<span class="math inline">\(c\)</span>值为正，则之前的平均变化情况是增长的，因此<span class="math inline">\(y_t\)</span>将倾向于继续向上漂移（drift）。反之如果<span class="math inline">\(c\)</span>值为负，<span class="math inline">\(y_t\)</span>将倾向于向下漂移。</p><h3 id="二阶差分">二阶差分</h3><p>有时差分后的数据仍然不平稳，所以可能需要再一次对数据进行差分来得到一个平稳的序列： <span class="math display">\[\begin{align*}  y&#39;&#39;_{t}  &amp;=  y&#39;_{t}  - y&#39;_{t - 1} \\           &amp;= (y_t - y_{t-1}) - (y_{t-1}-y_{t-2})\\           &amp;= y_t - 2y_{t-1} +y_{t-2}.\end{align*}\]</span> 在这种情况下，序列<span class="math inline">\(y_t&#39;&#39;\)</span>的长度为<span class="math inline">\(T-2\)</span>。之后我们可以对原数据的“变化的变化”进行建模。在现实应用中，通常没有必要进行二阶以上的差分。</p><h2 id="季节性差分">季节性差分</h2><p>季节性差分是对一个观测值和相对应的前一年的观测值之间进行差分。因此有： <span class="math display">\[y_t&#39; = y_t - y_{t-m},\]</span> 其中<span class="math inline">\(m=\)</span>一年中的季节数量。这也被称为“延迟-<span class="math inline">\(m\)</span>差值”，因为相减的两个观测值之间的时间间隔为<span class="math inline">\(m\)</span>。</p><p>如果季节性差分数据是白噪声，则原数据可以用一个合适的模型来拟合： <span class="math display">\[y_t = y_{t-m}+\varepsilon_t.\]</span> 这个模型的预测值等于对应季节的上一次观测值。换言之，这个模型提供季节性的朴素（naive）预测。</p><p>图<a href="https://wxbfans-ink.oss-cn-beijing.aliyuncs.com/img/20210606222125.png?x-oss-process=PicGo" target="_blank" rel="noopener">8.3</a> 中下方的图显示的是 A10（抗糖尿病）药剂在澳大利亚月销售量的对数的季节差值。经过变换和差分，序列变得相对平稳。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cbind(<span class="string">"销售量 ($百万)"</span> = a10,</span><br><span class="line">      <span class="string">"每月销量对数"</span> = log(a10),</span><br><span class="line">      <span class="string">"每年销量变化对数"</span> = diff(log(a10),<span class="number">12</span>)) %&gt;%</span><br><span class="line">  autoplot(facets=<span class="literal">TRUE</span>) +</span><br><span class="line">    xlab(<span class="string">"年份"</span>) + ylab(<span class="string">""</span>) +</span><br><span class="line">    ggtitle(<span class="string">"抗糖尿病药剂销量"</span>)+</span><br><span class="line">  theme(text = element_text(family = <span class="string">"STHeiti"</span>))+</span><br><span class="line">  theme(plot.title = element_text(hjust = <span class="number">0.5</span>))</span><br></pre></td></tr></table></figure><figure><img src="https://wxbfans-ink.oss-cn-beijing.aliyuncs.com/img/20210606222125.png?x-oss-process=PicGo" alt="A10（抗糖尿病）药剂销量的对数和季节性差值数据，对数变换稳定了方差，而季节性差分去除了数据的趋势和季节性。"><figcaption aria-hidden="true">A10（抗糖尿病）药剂销量的对数和季节性差值数据，对数变换稳定了方差，而季节性差分去除了数据的趋势和季节性。</figcaption></figure><blockquote><p>图 8.3: A10（抗糖尿病）药剂销量的对数和季节性差值数据，对数变换稳定了方差，而季节性差分去除了数据的趋势和季节性。</p></blockquote><p>为了区别季节差分和一般的差分，我们有时将一般的差分称为“一步差分”，即差值的延迟期数为 1。</p><p>正如图<a href="https://wxbfans-ink.oss-cn-beijing.aliyuncs.com/img/20210606222427.png?x-oss-process=PicGo" target="_blank" rel="noopener">8.4</a>所示，我们有时会同时使用季节性差分和一般的差分方法来得到平稳时间序列。在图中，我们先对数据进行对数变换（第二幅图），之后进行季节性差分（第三幅图）。经过上述操作后的数据仍然看起来有点非平稳，所以我们又进行了一次差分（第四幅图）。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cbind(<span class="string">"十亿千瓦时"</span> = usmelec,</span><br><span class="line">      <span class="string">"对数"</span> = log(usmelec),</span><br><span class="line">      <span class="string">"季节性\n 差分对数"</span> = diff(log(usmelec),<span class="number">12</span>),</span><br><span class="line">      <span class="string">"二次\n 差分对数"</span> = diff(diff(log(usmelec),<span class="number">12</span>),<span class="number">1</span>)) %&gt;%</span><br><span class="line">  autoplot(facets=<span class="literal">TRUE</span>) +</span><br><span class="line">    xlab(<span class="string">"年份"</span>) + ylab(<span class="string">""</span>) +</span><br><span class="line">    ggtitle(<span class="string">"美国电网每月发电量"</span>)+</span><br><span class="line">  theme(text = element_text(family = <span class="string">"STHeiti"</span>))+</span><br><span class="line">  theme(plot.title = element_text(hjust = <span class="number">0.5</span>))</span><br></pre></td></tr></table></figure><figure><img src="https://wxbfans-ink.oss-cn-beijing.aliyuncs.com/img/20210606222427.png?x-oss-process=PicGo" alt="第一幅图：美国电网每月发电量 (十亿千瓦时)。其他图显示的是该数据经过不同的变换和差分后的情况。"><figcaption aria-hidden="true">第一幅图：美国电网每月发电量 (十亿千瓦时)。其他图显示的是该数据经过不同的变换和差分后的情况。</figcaption></figure><blockquote><p>图 8.4: 第一幅图：美国电网每月发电量 (十亿千瓦时)。其他图显示的是该数据经过不同的变换和差分后的情况。</p></blockquote><p>选择使用哪些差分方式具有一定的主观性。图<a href="https://otexts.com/fppcn/stationarity.html#fig:a10diff" target="_blank" rel="noopener">8.3</a>中季节性差分的数据看起来和图<a href="https://otexts.com/fppcn/stationarity.html#fig:usmelec" target="_blank" rel="noopener">8.4</a>中季节性差分的数据差异并不大。在后一种情况中，我们可能会使用季节性差分后的数据，而不是进一步对数据进行差分。在前一种情况中，我们也可能认为季节性差分后的数据仍然不够平稳，因而进一步进行差分。我们将在后文中讨论一些严谨的差分检验，然而选择使用何种方式仍然是一个主观选择的过程，不同的分析师可能会做出不同的选择。</p><p>假如用<span class="math inline">\(y&#39;_t = y_t - y_{t-m}\)</span>表示季节性的差分序列，那么它的二阶差分序列则为： <span class="math display">\[\begin{align*}y&#39;&#39;_t &amp;= y&#39;_t - y&#39;_{t-1} \\      &amp;= (y_t - y_{t-m}) - (y_{t-1} - y_{t-m-1}) \\      &amp;= y_t -y_{t-1} - y_{t-m} + y_{t-m-1}\:\end{align*}\]</span> 当季节性差值和第一差值都被使用时，两者的先后顺序并不会影响结果——变换顺序后的结果仍是一样的。然而，如果数据的季节性特征比较强，我们建议先进行季节性差分，因为有时经过季节性差分的数据已经足够平稳，没有必要进行后续的差分。如果先进行第一差分，我们仍将需要做一次季节性差分。</p><p>当我们使用差分时，有一点非常重要：差值应该是可解释（interpretable）的。第一差分是相邻观测值之间的差值，季节性差分是相邻年份的观测值的变化。其他延迟期数的差分很难和这两者一样易于解释，因此应该尽力避免。</p><h3 id="单位根检验">单位根检验</h3><p><em>单位根检验</em>是一种更客观的判定是否需要差分的方法。这个针对平稳性的统计假设检验被用于判断是否需要差分方法来让数据更平稳。</p><p>单位根检验的方法有很多种，它们基于不同的假设，因此可能产生相互矛盾的结果。在我们的分析中，采用 <em>Kwiatkowski-Phillips-Schmidt-Shin (KPSS)</em> 检验(Kwiatkowski, Phillips, Schmidt, &amp; Shin, <a href="https://otexts.com/fppcn/stationarity.html#ref-KPSS92" target="_blank" rel="noopener">1992</a>)。在此检验中，原假设为数据是平稳的，我们要寻找能够证明原假设是错误的证据。因此，很小的P值（例如小于0.05）说明需要进行差分。该检验可以使用程序包<a href="https://www.statsmodels.org/stable/index.html" target="_blank" rel="noopener"><strong>statsmodels</strong></a>中的 <code>statsmodels.tsa.stattools.kpss()</code> 函数进行计算。</p><p>例如，让我们对谷歌的股价数据进行该检验。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from statsmodels.tsa.stattools import kpss</span><br><span class="line">import pandas as pd</span><br><span class="line">import yfinance as yf</span><br><span class="line">data = yf.download(<span class="string">"GOOG"</span>, start=<span class="string">"2013-01-01"</span>, end=<span class="string">"2013-12-06"</span>)</span><br><span class="line">kpss_output = pd.Series(kpss(data[<span class="string">'Close'</span>], regression=<span class="string">'c'</span>)[<span class="number">0</span>:<span class="number">3</span>], </span><br><span class="line">          index=[<span class="string">'Test Statistic'</span>, <span class="string">'p-value'</span>, <span class="string">'Lags used'</span>])</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> kpss(data[<span class="string">'Close'</span>], regression=<span class="string">'c'</span>)[<span class="number">3</span>].items():</span><br><span class="line">    kpss_output[<span class="string">'Critical Value (%s)'</span> % key] = value</span><br><span class="line">kpss_output</span><br><span class="line"><span class="comment"># Test Statistic            1.280268</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># p-value                   0.010000</span></span><br><span class="line"><span class="comment"># Lags used                15.000000</span></span><br><span class="line"><span class="comment"># Critical Value (10%)      0.347000</span></span><br><span class="line"><span class="comment"># Critical Value (5%)       0.463000</span></span><br><span class="line"><span class="comment"># Critical Value (2.5%)     0.574000</span></span><br><span class="line"><span class="comment"># Critical Value (1%)       0.739000</span></span><br><span class="line"><span class="comment"># dtype: float64</span></span><br></pre></td></tr></table></figure><p>检验统计量的值远大于临界值 1%，可以拒绝原假设，也就是说，该序列不平稳。我们可以对数据进行差分，再次进行检验。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> statsmodels.tsa.stattools <span class="keyword">import</span> kpss</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> yfinance <span class="keyword">as</span> yf</span><br><span class="line">data = yf.download(<span class="string">"GOOG"</span>, start=<span class="string">"2013-01-01"</span>, end=<span class="string">"2013-12-06"</span>)</span><br><span class="line">kpss_output = pd.Series(kpss(data[<span class="string">'Close'</span>] - data[<span class="string">'Open'</span>], regression=<span class="string">'c'</span>)[<span class="number">0</span>:<span class="number">3</span>], </span><br><span class="line">          index=[<span class="string">'Test Statistic'</span>, <span class="string">'p-value'</span>, <span class="string">'Lags used'</span>])</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> kpss(data[<span class="string">'Close'</span>] - data[<span class="string">'Open'</span>], regression=<span class="string">'c'</span>)[<span class="number">3</span>].items():</span><br><span class="line">    kpss_output[<span class="string">'Critical Value (%s)'</span> % key] = value</span><br><span class="line">kpss_output</span><br><span class="line"><span class="comment"># Test Statistic            0.088083</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># p-value                   0.100000</span></span><br><span class="line"><span class="comment"># Lags used                15.000000</span></span><br><span class="line"><span class="comment"># Critical Value (10%)      0.347000</span></span><br><span class="line"><span class="comment"># Critical Value (5%)       0.463000</span></span><br><span class="line"><span class="comment"># Critical Value (2.5%)     0.574000</span></span><br><span class="line"><span class="comment"># Critical Value (1%)       0.739000</span></span><br><span class="line"><span class="comment"># dtype: float64</span></span><br></pre></td></tr></table></figure><p>这次检验的统计量的值很小，处在期望的范围以内，因此可以推断出差分后的序列是平稳的。</p><p>函数<code>ndiffs</code>可以通过一系列的KPSS检验来确定合适的一阶差分次数。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ndiffs(goog)</span><br><span class="line"><span class="comment">#&gt; [1] 1</span></span><br></pre></td></tr></table></figure><p>从上面的 KPSS 检验可以看出，需要进行一次差分来让<code>goog</code>数据变得平稳。</p><p>与上述函数类似，<code>nsdiffs</code>函数可以用来确定是否需要进行季节性差分，它通过季节性强度来确定合适的季节性差分次数，如果<span class="math inline">\(F_S&lt;0.64\)</span>，不需要进行季节性差分，否则需要进行一次季节性差分。</p><p>对美国月度用电数据使用<code>nsdiffs()</code>函数。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">usmelec %&gt;% log() %&gt;% nsdiffs()</span><br><span class="line"><span class="comment">#&gt; [1] 1</span></span><br><span class="line">usmelec %&gt;% log() %&gt;% diff(lag=<span class="number">12</span>) %&gt;% ndiffs()</span><br><span class="line"><span class="comment">#&gt; [1] 1</span></span><br></pre></td></tr></table></figure><p>由于<code>nsdiffs()</code>函数返回 1，（说明需要进行一次季节性差分），我们对季节差分后的数据运行<code>ndiffs()</code>函数。这些函数的运行结果说明我们应该进行一次季节性差分和一次一步差分。</p><h3 id="参考文献">参考文献</h3><p>Hyndman R J, Athanasopoulos G. Forecasting: principles and practice[M]. OTexts, 2018.</p><p>ARIMA模型的优缺点，优点是模型十分简单，只需要内生变量而不需要借助其他外生变量。以最简单的模型 Y = aX + b 为例，X 是自变量，Y是因变量，a 和 b 都是外生变量，是由模型的外部因素决定的。</p><p>缺点：</p><ol type="1"><li>要求时序数据是稳定的（stationary），或者通过差分化（differencing）后是稳定的。</li><li>本质上只能捕捉线性关系，而不能捕捉非线性关系。</li></ol><p>那么要如何判断时序数据是稳定的呢？</p><p>一个时间序列的随机变量是稳定的，当且仅当它的统计特征都是独立于时间的（是关于时间的常量）。</p><ol type="1"><li>稳定的数据是没有趋势（trend），没有周期性（seasonality）的；即它的均值，在时间轴上拥有常量的振幅，并且它的方差，在时间轴上是趋于同一个稳定的值的。</li><li>可以用Dickey-Fuller Test 进行假设检验。</li></ol><p>ARIMA的参数与数学形式</p><p>ARIMA模型有三个参数p,d,q</p><ul><li>p -- 代表预测模型中采用的时序数据本身的滞后数（lags），也叫做AR/Auto-Regressive项。</li><li>d -- 代表时序数据需要进行几阶差分化才是稳定的，也叫Integrated项。</li><li>q -- 代表预测模型中采用的预测误差的滞后数（lags），也叫MA/Moving Average项。</li></ul><p>差分 -- 假设y表示t时刻的Y的差分</p><p>ARIMA的预测模型可以表示为：</p><p>Y的预测值 = 常量c and/or 一个或多个最近时间的Y的加权 and/or 一个或多个最近时间的预测误差。</p><p>假设p,q,d已知：</p><p>ARIMA用数学形式表示为: <span class="math display">\[ytˆ=μ+ϕ1∗yt−1+...+ϕp∗yt−p+θ1∗et−1+...+θq∗et−q其中,ϕ表示AR的系数，θ表示MA的系数\]</span> ARIMA模型的几个特例</p><ol type="1"><li><p>ARIMA(0,1,0) = random walk:</p><p>当d=1,p 和 q 为0 时，叫做random walk，每一个时刻的Y，只与上一时刻的Y有关。 <span class="math display">\[Yˆt=μ+Yt−1\]</span></p></li><li><p>ARIMA(1,0,0) = first-order autoregressive model:</p><p>当p=1,d=0,q=0,说明时序数据是稳定的和自相关的。一个时刻的Y值只与上一个时刻的Y值有关 <span class="math display">\[Yˆt=μ+ϕ1∗Yt−1.where, ϕ∈[−1,1],是一个斜率系数\]</span></p></li><li><p>ARIMA(1,1,0) = differenced first-order autoregressive model: p=1,d=1,q=0. 说明时序数据在一阶差分化之后是稳定的和自回归的。即一个时刻的差分（y）只与上一个时刻的差分有关。 <span class="math display">\[yˆt=μ+ϕ1∗yt−1结合一阶差分的定义，也可以表示为：Yˆt−Yt−1=μ+ϕ1∗(Yt−1−Yt−2)或者Yˆt=μ+Yt−1+ϕ1∗(Yt−1−Yt−2)\]</span></p></li><li><p>ARIMA(0,1,1) = simple exponential smoothing with growth. p=0, d=1 ,q=1.说明数据在一阶差分后市稳定的和移动平均的。即一个时刻的估计值的差分与上一个时刻的预测误差有关。 <span class="math display">\[  yˆt=μ+α1∗et−1注意q=1的差分yt与p=1的差分yt的是不一样的其中，yˆt=Yˆt−Yˆt−1, et−1=Yt−1−Yˆt−1,设θ1=1−α1则也可以写成：Yˆt=μ+Yˆt−1+α1(Yt−1−Yˆt−1)=μ+Yt−1−θ1∗et−1\]</span></p></li><li><p>ARIMA(2,1,2) 在通过上面的例子，可以很轻松的写出它的预测模型： <span class="math display">\[yˆt=μ+ϕ1∗yt−1+ϕ2∗yt−2−θ1∗et−1−θ2∗et−2也可以写成:Yˆt=μ+ϕ1∗(Yt−1−Yt−2)+ϕ2∗(Yt−2−Yt−3)−θ1∗(Yt−1−Yˆt−1)−θ2∗(Yt−2−Yˆt−2)\]</span></p></li><li><p>ARIMA(2,2,2) <span class="math display">\[yˆt=μ+ϕ1∗yt−1+ϕ2∗yt−2−θ1∗et−1−θ2∗et−2Yˆt=μ+ϕ1∗(Yt−1−2Yt−2+Yt−3)+ϕ2∗(Yt−2−2Yt−3+Yt−4)−θ1∗(Yt−1−Yˆt−1)−θ2∗(Yt−2−Yˆt−2)\]</span></p></li></ol><p>ARIMA建模基本步骤</p><ol type="1"><li>获取被观测系统时间序列数据；</li><li>对数据绘图，观测是否为平稳时间序列；对于非平稳时间序列要先进行d阶差分运算，化为平稳时间序列；</li><li>经过第二步处理，已经得到平稳时间序列。要对平稳时间序列分别求得其自相关系数ACF 和偏自相关系数PACF，通过对自相关图和偏自相关图的分析，得到最佳的阶层 p 和阶数 q</li><li>由以上得到的d、q、p，得到ARIMA模型。然后开始对得到的模型进行模型检验。</li></ol>]]></content:encoded>
      
      <comments>https://ningoy.github.io/2021/06/04/%E4%BD%BF%E7%94%A8ARIMA%E6%A8%A1%E5%9E%8B%E8%BF%9B%E8%A1%8C%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E5%88%86%E6%9E%90/#disqus_thread</comments>
    </item>
    
    <item>
      <title>处理数据常用的命令行工具</title>
      <link>https://ningoy.github.io/2020/03/27/%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</link>
      <guid>https://ningoy.github.io/2020/03/27/%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</guid>
      <pubDate>Fri, 27 Mar 2020 15:03:09 GMT</pubDate>
      <description>
      
        
        
          &lt;h4 id=&quot;head-tail&quot;&gt;head &amp;amp; tail&lt;/h4&gt;
&lt;hr&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;head&lt;/code&gt; 默认打印出文件的前&lt;code&gt;10&lt;/code&gt; 行，&lt;code&gt;tail&lt;/code&gt; 默认打印出文件的
        
      
      </description>
      
      <content:encoded><![CDATA[<h4 id="head-tail">head &amp; tail</h4><hr><ol type="1"><li><p><code>head</code> 默认打印出文件的前<code>10</code> 行，<code>tail</code> 默认打印出文件的最后<code>10</code> 行。</p></li><li><p>也可以使用<code>head -n 5 shakespeare_6.0.json</code> 或是 <code>head -5 shakespeare_6.0.json</code> 打印出前<code>5</code> 行。用<code>tail -n 5 shakespeare_6.0.json</code> 或 <code>tail -5 shakespeare_6.0.json</code> 打印出文件最后<code>5</code> 行。</p></li><li><p><code>head -n 10010 listings.csv | tail -10</code> 和 <code>tail -n +10001 listings.csv | head -n 10</code> 表示同一个意思，即是打印 <code>10001-10010</code> 行。</p></li><li><p><code>tail -f listings.csv</code> 这个命令既打印 <code>listings.csv</code> 文件的最后<code>10</code> 行，也能在<code>listings.csv</code> 文件行数增长时，继续打印新增的行。</p></li></ol><h4 id="tr">tr</h4><hr><ol type="1"><li><p><code>head -n 10 listings.csv | tr ',' '\t'</code> 可以将<code>.csv</code> 文件中的<code>,</code> 分隔符换成<code>\t</code> 分隔符。</p></li><li><p><code>head -n 10 listings.csv | tr -d ','</code> 可以将<code>.csv</code> 文件中的<code>,</code> 分隔符去掉。</p></li><li><p><code>head -n 10 listings.csv | tr "[:lower:]" "[:upper:]"</code> 可以将 <code>.csv</code> 文件中的小写字母换成大写字母，而这是通过<code>[:class:]</code> 做到的。</p><ul><li><code>[:alnum:]</code> 所有字母和数字</li></ul></li></ol><ul><li><code>[:alpha:]</code> 所有字母<ul><li><code>[:blank:]</code> 所有水平空白</li></ul></li><li><code>[:cntrl:]</code> 所有控制字符<ul><li><code>[:digit:]</code> 所有数字</li></ul></li><li><code>[:graph:]</code> 所有可打印字符，但不包括空格<ul><li><code>[:lower:]</code> 所有小写字母</li></ul></li><li><code>[:print:]</code> 所有可打印字符，包括空格<ul><li><code>[:punct:]</code> 所有标点符号</li></ul></li><li><code>[:space:]</code> 所有水平或垂直空白<ul><li><code>[:upper:]</code> 所有大写字母</li></ul></li><li><code>[:xdigit:]</code> 所有 16 进制数字</li></ul><h4 id="wc">wc</h4><hr><ol type="1"><li><code>wc -l listings.csv</code> 打印 <code>listings.csv</code> 的行数。</li></ol><h4 id="sort-uniq">sort &amp; uniq</h4><hr><ol type="1"><li><p><code>uniq</code> 只作用于重复的相邻行，因此最好先对要处理的文件进行<code>sort</code> 。</p></li><li><p><code>head -500 listings.csv | awk -F ',' '{print $6}' | sort | uniq -c | sort -nr</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> sort 先排序，使得重复的行相邻便于uniq统计</span><br><span class="line"><span class="meta">#</span> 之后uniq -c 统计每一行重复的次数</span><br><span class="line"><span class="meta">#</span> 再通过sort -nr降序排列</span><br><span class="line"><span class="meta">#</span> 这样可以很快找到重复次数最多的一行</span><br><span class="line">    201 朝阳区 / Chaoyang</span><br><span class="line">     65 东城区</span><br><span class="line">     53 </span><br><span class="line">     34 海淀区</span><br><span class="line">     27 西城区</span><br><span class="line">     24 丰台区 / Fengtai</span><br><span class="line">     14 顺义区 / Shunyi</span><br><span class="line">     12 昌平区</span><br><span class="line">     12 怀柔区 / Huairou</span><br><span class="line">      6 通州区 / Tongzhou</span><br><span class="line">      5 密云县 / Miyun</span><br></pre></td></tr></table></figure></li><li><p><code>head -10 reviews.csv | tr ',' ' ' | sort -t" " -k2,2</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> -t 选项将" "指定为分隔符</span><br><span class="line"><span class="meta">#</span> -k 选项用来确定排序的键</span><br><span class="line"><span class="meta">#</span> -k2,2 意为 第2列为开始列 第2列为结束列</span><br><span class="line">44054 2010-08-25</span><br><span class="line">44054 2010-10-13</span><br><span class="line">44054 2011-08-11</span><br><span class="line">44054 2012-04-12</span><br><span class="line">44054 2012-08-30</span><br><span class="line">44054 2012-09-28</span><br><span class="line">44054 2012-10-04</span><br><span class="line">44054 2012-11-15</span><br><span class="line">44054 2013-03-08</span><br><span class="line">listing_id date</span><br></pre></td></tr></table></figure></li><li><p><code>head -n +100 reviews.csv | tail -10  | tr ',' ' ' | sort -t" " -k1n,1</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> -k1n,1 意为 第1列为开始列 第2列为结束列 同时第一列为数字 采用数字大小排序</span><br><span class="line">100213 2017-08-27</span><br><span class="line">100213 2017-10-08</span><br><span class="line">128496 2011-06-02</span><br><span class="line">128496 2011-06-05</span><br><span class="line">128496 2011-08-02</span><br><span class="line">128496 2011-08-26</span><br><span class="line">128496 2011-09-04</span><br><span class="line">128496 2011-09-07</span><br><span class="line">128496 2011-09-12</span><br><span class="line">128496 2011-09-19</span><br></pre></td></tr></table></figure></li></ol><h4 id="cut">cut</h4><hr><ol type="1"><li><code>cut</code> 用于选择列，<code>cut -d',' -f 1,3 listings.csv | head -10</code> 选择第1列和第3列。</li><li><code>head listings.csv | cut -d ',' -f 6-</code> 选择第6列以后的（包括第6列）所有列。</li></ol><h4 id="jq">jq</h4><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">head -n 4 shakespeare_6.0.json</span><br><span class="line"></span><br><span class="line">&#123;"index":&#123;"_index":"shakespeare","_id":0&#125;&#125;</span><br><span class="line">&#123;"type":"act","line_id":1,"play_name":"Henry IV", "speech_number":"","line_number":"","speaker":"","text_entry":"ACT I"&#125;</span><br><span class="line">&#123;"index":&#123;"_index":"shakespeare","_id":1&#125;&#125;</span><br><span class="line">&#123;"type":"scene","line_id":2,"play_name":"Henry IV","speech_number":"","line_number":"","speaker":"","text_entry":"SCENE I. London. The palace."&#125;</span><br><span class="line"></span><br><span class="line">head -n 4 shakespeare_6.0.json | jq</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "index": &#123;</span><br><span class="line">    "_index": "shakespeare",</span><br><span class="line">    "_id": 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  "type": "act",</span><br><span class="line">  "line_id": 1,</span><br><span class="line">  "play_name": "Henry IV",</span><br><span class="line">  "speech_number": "",</span><br><span class="line">  "line_number": "",</span><br><span class="line">  "speaker": "",</span><br><span class="line">  "text_entry": "ACT I"</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  "index": &#123;</span><br><span class="line">    "_index": "shakespeare",</span><br><span class="line">    "_id": 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  "type": "scene",</span><br><span class="line">  "line_id": 2,</span><br><span class="line">  "play_name": "Henry IV",</span><br><span class="line">  "speech_number": "",</span><br><span class="line">  "line_number": "",</span><br><span class="line">  "speaker": "",</span><br><span class="line">  "text_entry": "SCENE I. London. The palace."</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">head -n 4 shakespeare_6.0.json | jq ".text_entry"</span><br><span class="line"></span><br><span class="line">null</span><br><span class="line">"ACT I"</span><br><span class="line">null</span><br><span class="line">"SCENE I. London. The palace."</span><br></pre></td></tr></table></figure><h4 id="sed-awk">sed &amp; awk</h4>]]></content:encoded>
      
      <comments>https://ningoy.github.io/2020/03/27/%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>561. Array Partition I</title>
      <link>https://ningoy.github.io/2018/05/05/561-Array-Partition-I/</link>
      <guid>https://ningoy.github.io/2018/05/05/561-Array-Partition-I/</guid>
      <pubDate>Sat, 05 May 2018 07:42:00 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;Given an array of &lt;strong&gt;2n&lt;/strong&gt; integers, your task is to group these integers into &lt;strong&gt;n&lt;/strong&gt; pairs of integ
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>Given an array of <strong>2n</strong> integers, your task is to group these integers into <strong>n</strong> pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.</p></blockquote><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,4,3,2]</span><br><span class="line"></span><br><span class="line">Output: 4</span><br><span class="line">Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol type="1"><li><strong>n</strong> is a positive integer, which is in the range of [1, 10000].</li><li>All the integers in the array will be in the range of [-10000, 10000].</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20001</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)&#123;</span><br><span class="line">            count[i + <span class="number">10000</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span> odd = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count.length; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(count[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(odd)&#123;</span><br><span class="line">                    res += i - <span class="number">10000</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                odd = !odd;</span><br><span class="line">                count[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://ningoy.github.io/2018/05/05/561-Array-Partition-I/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
