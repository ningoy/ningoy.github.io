<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>关爱颈椎成长协会</title>
    <link>https://ningoy.github.io/</link>
    <atom:link href="/ningoy.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Fri, 04 Jun 2021 11:12:13 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>使用ARIMA模型进行时间序列分析</title>
      <link>https://ningoy.github.io/2021/06/04/%E4%BD%BF%E7%94%A8ARIMA%E6%A8%A1%E5%9E%8B%E8%BF%9B%E8%A1%8C%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E5%88%86%E6%9E%90/</link>
      <guid>https://ningoy.github.io/2021/06/04/%E4%BD%BF%E7%94%A8ARIMA%E6%A8%A1%E5%9E%8B%E8%BF%9B%E8%A1%8C%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E5%88%86%E6%9E%90/</guid>
      <pubDate>Fri, 04 Jun 2021 09:54:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;ARIMA模型&quot;&gt;&lt;a href=&quot;#ARIMA模型&quot; class=&quot;headerlink&quot; title=&quot;ARIMA模型&quot;&gt;&lt;/a&gt;ARIMA模型&lt;/h1&gt;&lt;p&gt;ARIMA模型，自回归移动平均模型（ARIMA，Autoregressive Integrated 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="ARIMA模型"><a href="#ARIMA模型" class="headerlink" title="ARIMA模型"></a>ARIMA模型</h1><p>ARIMA模型，自回归移动平均模型（ARIMA，Autoregressive Integrated Moving Average Model），是统计模型中最常见的一种用来进行时间序列预测的模型，旨在描绘数据的自回归性（autocorrelations）。</p><p>在引入ARIMA模型之前，我们需要先讨论平稳性（stationarity）和差分时间序列（differencing time series）的相关知识。</p><h2 id="平稳性和差分"><a href="#平稳性和差分" class="headerlink" title="平稳性和差分"></a>平稳性和差分</h2><p>平稳的时间序列的性质不随观测时间的变化而变化。因此具有趋势或季节性的时间序列不是平稳时间序列——趋势和季节性使得时间序列在不同时段呈现不同特质。与他们相反，白噪声序列（white noise series）则是平稳的——不管观测的时间如何变化，它看起来都应该是一样的。</p><p><img src="http://wxbfans-ink.oss-cn-beijing.aliyuncs.com/img/stationary-1.png?x-oss-process=PicGo" alt="图中的时间序列有哪些是平稳的？（a）连续292天的谷歌股价; （b）连续292天谷歌股价的每日变化量; （c）美国各年的罢工总次数; （d）美国独立家庭住宅的每月价格; （e）按不变美元计算的美国的鸡蛋价格; （e）每月在澳大利亚维多利亚州被屠宰的猪的数量; （g）每年在加拿大西北的麦肯齐河停留的猞猁数量; （h）澳大利亚每月啤酒产量; （i）澳大利亚每月发电量"></p><blockquote><p>图 8.1: 图中的时间序列有哪些是平稳的？（a）连续292天的谷歌股价; （b）连续292天谷歌股价的每日变化量; （c）美国各年的罢工总次数; （d）美国独立家庭住宅的每月价格; （e）按不变美元计算的美国的鸡蛋价格; （e）每月在澳大利亚维多利亚州被屠宰的猪的数量; （g）每年在加拿大西北的麦肯齐河停留的猞猁数量; （h）澳大利亚每月啤酒产量; （i）澳大利亚每月发电量</p></blockquote><p>考虑图<a href="http://wxbfans-ink.oss-cn-beijing.aliyuncs.com/img/stationary-1.png?x-oss-process=PicGo" target="_blank" rel="noopener">8.1</a>中的九个时间序列，其中有哪些是平稳的时间序列？</p><p>显然存在季节性的序列（d）、（h）和（i）可以被排除。存在趋势的序列（a）、（c）、（e）、（f）和（i）也应该被排除，除此之外，序列（i）的方差随时间增大，也不符合平稳时间序列的性质。用上述方法排除后，剩下的（b）和（g）是平稳时间序列。</p><p>序列（g）的循环变化让它第一眼看上去不太平稳，但是这种变化其实是不定期的——当猞猁的数量超过食物承载的上限时，它们会停止繁殖从而使得数量回落到非常低的水平，之后食物来源的再生使得猞猁数量重新增长，周而复始。从长期来看，这种循环的时间点是不能预测的，因此序列（g）是平稳的。</p><h3 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h3><p>在图 <a href="https://otexts.com/fppcn/stationarity.html#fig:stationary" target="_blank" rel="noopener">8.1</a>中，我们注意到（a）中谷歌股价数并不平稳，但（b）中谷歌股价每天的变化量则是平稳的。这向我们展示了一种让非平稳时间序列变平稳的方法——计算相邻观测值之间的差值，这种方法被称为<strong>差分</strong>。</p><p>诸如对数变换的变换方法可用于平稳化（stabilize）时间序列的方差。差分则可以通过去除时间序列中的一些变化特征来平稳化它的均值，并因此消除（或减小）时间序列的趋势和季节性。</p><p>和时间曲线图一样，自相关图（ACF图）也能帮助我们识别非平稳时间序列。 对于一个平稳时间序列,自相关系数（ACF）会快速的下降到接近 0 的水平，然而非平稳时间序列的自相关系数会下降的比较缓慢。同样的,非平稳时间序列的 r1r1 通常非常大并且为正值。</p><p><img src="http://wxbfans-ink.oss-cn-beijing.aliyuncs.com/img/acfstationary-1.png?x-oss-process=PicGo" alt="谷歌股价（左图）和谷歌股价的每日变化（右图）的自相关系数。"></p><blockquote><p>图 8.2: 谷歌股价（左图）和谷歌股价的每日变化（右图）的自相关系数。</p></blockquote><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Box.test(diff(goog200),lag=<span class="number">10</span>,type=<span class="string">"Ljung-Box"</span>)</span><br><span class="line"><span class="comment">#&gt; </span></span><br><span class="line"><span class="comment">#&gt;  Box-Ljung test</span></span><br><span class="line"><span class="comment">#&gt; </span></span><br><span class="line"><span class="comment">#&gt; data:  diff(goog200)</span></span><br><span class="line"><span class="comment">#&gt; X-squared = 11, df = 10, p-value = 0.4</span></span><br></pre></td></tr></table></figure><p>差分后的谷歌股价的自相关图看起来像白噪声序列。所有自回归系数都在 95% 的置信度以内，并且 Ljung-Box 检验中 Q∗Q∗ 统计量的<em>p</em>值为 0.355 (for h=10h=10)。这反映出谷歌股价的<em>每日变化</em>在本质上是一个与过去时间无关的随机值。</p><h3 id="随机游走模型"><a href="#随机游走模型" class="headerlink" title="随机游走模型"></a>随机游走模型</h3><p>差分序列是指原序列的连续观测值之间的<em>变化值</em>组成的时间序列，它可以被表示为：<br>$$<br>y′t=yt−yt−1.<br>$$<br>差分序列的长度为 T−1T−1，因为 t=1t=1 时，公式中的差值无法计算。</p><p>当差分序列是白噪声时，原序列的模型可以表示为：<br>$$<br>yt−yt−1=εt,<br>$$<br>这里的 εtεt 为白噪声。调整上式,即可得到“随机游走”模型：<br>$$<br>yt=yt−1+εt.<br>$$<br>随机游走模型在非平稳时间序列数据中应用广泛,特别是金融和经济数据.典型的随机游走通常具有以下特征：</p><ul><li>长期的明显上升或下降趋势。</li><li>游走方向上突然的、不能预测的变化。</li></ul><p>由于未来变化是不可预测的，随机游走模型的预测值为上一次观测值，并且其上升和下降的可能性相同。因此，随机游走模型适用于朴素（naive）的预测，这在章节<a href="https://otexts.com/fppcn/simple-methods.html#simple-methods" target="_blank" rel="noopener">3.1</a>中已经提到过了。</p><p>通过稍许改进,我们可以让差值均值不为零. 从而：<br>$$<br>yt−yt−1=c+εtoryt=c+yt−1+εt.<br>$$<br>cc 值是连续观测值变化的平均值。如果 cc 值为正，则之前的平均变化情况是增长的,因此 ytyt 将倾向于继续向上漂移（drift）。反之如果 cc 值为负，ytyt 将倾向于向下漂移。</p><p>这就是本书<a href="https://otexts.com/fppcn/simple-methods.html#simple-methods" target="_blank" rel="noopener">3.1</a>章节中讨论的漂移方法背后的模型。</p><h3 id="二阶差分"><a href="#二阶差分" class="headerlink" title="二阶差分"></a>二阶差分</h3><p>有时差分后的数据仍然不平稳，所以可能需要再一次对数据进行差分来得到一个平稳的序列：<br>$$<br>y′′t=y′t−y′t−1=(yt−yt−1)−(yt−1−yt−2)=yt−2yt−1+yt−2.<br>$$<br>在这种情况下，序列 y′′tyt″ 的长度为 T−2T−2。之后我们可以对原数据的“变化的变化”进行建模。在现实应用中，通常没有必要进行二阶以上的差分。</p><h2 id="季节性差分"><a href="#季节性差分" class="headerlink" title="季节性差分"></a>季节性差分</h2><p>季节性差分是对一个观测值和相对应的前一年的观测值之间进行差分。因此有：<br>$$<br>y′t=yt−yt−m,<br>$$<br>其中 m=m= 一年中的季节数量。这也被称为“延迟-mm 差值”，因为相减的两个观测值之间的时间间隔为 mm。</p><p>如果季节性差分数据是白噪声，则原数据可以用一个合适的模型来拟合：<br>$$<br>yt=yt−m+εt.<br>$$<br>这个模型的预测值等于对应季节的上一次观测值。换言之，这个模型提供季节性的朴素（naive）预测，本书<a href="https://otexts.com/fppcn/simple-methods.html#simple-methods" target="_blank" rel="noopener">3.1</a>有相关的介绍。</p><p>图<a href="https://otexts.com/fppcn/stationarity.html#fig:a10diff" target="_blank" rel="noopener">8.3</a> 中下方的图显示的是 A10（抗糖尿病）药剂在澳大利亚月销售量的对数的季节差值。经过变换和差分，序列变得相对平稳。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cbind(<span class="string">"销售量 ($百万)"</span> = a10,</span><br><span class="line">      <span class="string">"每月销量对数"</span> = log(a10),</span><br><span class="line">      <span class="string">"每年销量变化对数"</span> = diff(log(a10),<span class="number">12</span>)) %&gt;%</span><br><span class="line">  autoplot(facets=<span class="literal">TRUE</span>) +</span><br><span class="line">    xlab(<span class="string">"年份"</span>) + ylab(<span class="string">""</span>) +</span><br><span class="line">    ggtitle(<span class="string">"抗糖尿病药剂销量"</span>)+</span><br><span class="line">  theme(text = element_text(family = <span class="string">"STHeiti"</span>))+</span><br><span class="line">  theme(plot.title = element_text(hjust = <span class="number">0.5</span>))</span><br></pre></td></tr></table></figure><p><img src="https://otexts.com/fppcn/fpp_files/figure-html/a10diff-1.png" alt="A10（抗糖尿病）药剂销量的对数和季节性差值数据，对数变换稳定了方差，而季节性差分去除了数据的趋势和季节性。"></p><blockquote><p>图 8.3: A10（抗糖尿病）药剂销量的对数和季节性差值数据，对数变换稳定了方差，而季节性差分去除了数据的趋势和季节性。</p></blockquote><p>为了区别季节差分和一般的差分，我们有时将一般的差分称为“一步差分”，即差值的延迟期数为 1。</p><p>正如图<a href="https://otexts.com/fppcn/stationarity.html#fig:usmelec" target="_blank" rel="noopener">8.4</a>所示，我们有时会同时使用季节性差分和一般的差分方法来得到平稳时间序列。在图中，我们先对数据进行对数变换（第二幅图），之后进行季节性差分（第三幅图）。经过上述操作后的数据仍然看起来有点非平稳，所以我们又进行了一次差分（第四幅图）。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cbind(<span class="string">"十亿千瓦时"</span> = usmelec,</span><br><span class="line">      <span class="string">"对数"</span> = log(usmelec),</span><br><span class="line">      <span class="string">"季节性\n 差分对数"</span> = diff(log(usmelec),<span class="number">12</span>),</span><br><span class="line">      <span class="string">"二次\n 差分对数"</span> = diff(diff(log(usmelec),<span class="number">12</span>),<span class="number">1</span>)) %&gt;%</span><br><span class="line">  autoplot(facets=<span class="literal">TRUE</span>) +</span><br><span class="line">    xlab(<span class="string">"年份"</span>) + ylab(<span class="string">""</span>) +</span><br><span class="line">    ggtitle(<span class="string">"美国电网每月发电量"</span>)+</span><br><span class="line">  theme(text = element_text(family = <span class="string">"STHeiti"</span>))+</span><br><span class="line">  theme(plot.title = element_text(hjust = <span class="number">0.5</span>))</span><br></pre></td></tr></table></figure><p><img src="https://otexts.com/fppcn/fpp_files/figure-html/usmelec-1.png" alt="第一幅图：美国电网每月发电量 (十亿千瓦时)。其他图显示的是该数据经过不同的变换和差分后的情况。"></p><blockquote><p>图 8.4: 第一幅图：美国电网每月发电量 (十亿千瓦时)。其他图显示的是该数据经过不同的变换和差分后的情况。</p></blockquote><p>选择使用哪些差分方式具有一定的主观性。图<a href="https://otexts.com/fppcn/stationarity.html#fig:a10diff" target="_blank" rel="noopener">8.3</a>中季节性差分的数据看起来和图<a href="https://otexts.com/fppcn/stationarity.html#fig:usmelec" target="_blank" rel="noopener">8.4</a>中季节性差分的数据差异并不大。在后一种情况中，我们可能会使用季节性差分后的数据，而不是进一步对数据进行差分。在前一种情况中，我们也可能认为季节性差分后的数据仍然不够平稳，因而进一步进行差分。我们将在后文中讨论一些严谨的差分检验,然而选择使用何种方式仍然是一个主观选择的过程，不同的分析师可能会做出不同的选择。</p><p>假如用 y′t=yt−yt−myt′=yt−yt−m 表示季节性的差分序列，那么它的二阶差分序列则为：<br>$$<br>y′′t=y′t−y′t−1=(yt−yt−m)−(yt−1−yt−m−1)=yt−yt−1−yt−m+yt−m−1<br>$$<br>当季节性差值和第一差值都被使用时，两者的先后顺序并不会影响结果——变换顺序后的结果仍是一样的。然而，如果数据的季节性特征比较强，我们建议先进行季节性差分，因为有时经过季节性差分的数据已经足够平稳，没有必要进行后续的差分。如果先进行第一差分,我们仍将需要做一次季节性差分。</p><p>当我们使用差分时，有一点非常重要：差值应该是可解释（interpretable）的。第一差分是相邻观测值之间的差值，季节性差分是相邻年份的观测值的变化。其他延迟期数的差分很难和这两者一样易于解释，因此应该尽力避免。</p><h3 id="单位根检验"><a href="#单位根检验" class="headerlink" title="单位根检验"></a>单位根检验</h3><p><em>单位根检验</em>是一种更客观的判定是否需要差分的方法。这个针对平稳性的统计假设检验被用于判断是否需要差分方法来让数据更平稳。</p><p>单位根检验的方法有很多种，它们基于不同的假设，因此可能产生相互矛盾的结果。在我们的分析中，采用 <em>Kwiatkowski-Phillips-Schmidt-Shin (KPSS)</em> 检验(Kwiatkowski, Phillips, Schmidt, &amp; Shin, <a href="https://otexts.com/fppcn/stationarity.html#ref-KPSS92" target="_blank" rel="noopener">1992</a>)。在此检验中，原假设为数据是平稳的，我们要寻找能够证明原假设是错误的证据。因此，很小的P值（例如小于0.05）说明需要进行差分。该检验可以使用程序包<a href="https://cran.r-project.org/package=urca" target="_blank" rel="noopener"><strong>urca</strong></a>中的 <code>ur.kpss()</code> 函数进行计算。</p><p>例如，让我们对谷歌的股价数据进行该检验。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(urca)</span><br><span class="line">goog %&gt;% ur.kpss() %&gt;% summary()</span><br><span class="line"><span class="comment">#&gt; </span></span><br><span class="line"><span class="comment">#&gt; ####################### </span></span><br><span class="line"><span class="comment">#&gt; # KPSS Unit Root Test # </span></span><br><span class="line"><span class="comment">#&gt; ####################### </span></span><br><span class="line"><span class="comment">#&gt; </span></span><br><span class="line"><span class="comment">#&gt; Test is of type: mu with 7 lags. </span></span><br><span class="line"><span class="comment">#&gt; </span></span><br><span class="line"><span class="comment">#&gt; Value of test-statistic is: 10.72 </span></span><br><span class="line"><span class="comment">#&gt; </span></span><br><span class="line"><span class="comment">#&gt; Critical value for a significance level of: </span></span><br><span class="line"><span class="comment">#&gt;                 10pct  5pct 2.5pct  1pct</span></span><br><span class="line"><span class="comment">#&gt; critical values 0.347 0.463  0.574 0.739</span></span><br></pre></td></tr></table></figure><p>检验统计量的值远大于临界值 1%，可以拒绝原假设，也就是说，该序列不平稳。我们可以对对数据进行差分，再次进行检验。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">goog %&gt;% diff() %&gt;% ur.kpss() %&gt;% summary()</span><br><span class="line"><span class="comment">#&gt; </span></span><br><span class="line"><span class="comment">#&gt; ####################### </span></span><br><span class="line"><span class="comment">#&gt; # KPSS Unit Root Test # </span></span><br><span class="line"><span class="comment">#&gt; ####################### </span></span><br><span class="line"><span class="comment">#&gt; </span></span><br><span class="line"><span class="comment">#&gt; Test is of type: mu with 7 lags. </span></span><br><span class="line"><span class="comment">#&gt; </span></span><br><span class="line"><span class="comment">#&gt; Value of test-statistic is: 0.0324 </span></span><br><span class="line"><span class="comment">#&gt; </span></span><br><span class="line"><span class="comment">#&gt; Critical value for a significance level of: </span></span><br><span class="line"><span class="comment">#&gt;                 10pct  5pct 2.5pct  1pct</span></span><br><span class="line"><span class="comment">#&gt; critical values 0.347 0.463  0.574 0.739</span></span><br></pre></td></tr></table></figure><p>这次检验的统计量的值很小，处在期望的范围以内，因此可以推断出差分后的序列是平稳的。</p><p>函数<code>ndiffs</code>可以通过一系列的KPSS检验来确定合适的一阶差分次数。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ndiffs(goog)</span><br><span class="line"><span class="comment">#&gt; [1] 1</span></span><br></pre></td></tr></table></figure><p>从上面的 KPSS 检验可以看出，需要进行一次差分来让<code>goog</code>数据变得平稳。</p><p>与上述函数类似，<code>nsdiffs</code>函数可以用来确定是否需要进行季节性差分，，它通过<a href="https://otexts.com/fppcn/seasonal-strength.html#seasonal-strength" target="_blank" rel="noopener">6.7</a>中介绍的季节性强度来确定合适的季节性差分次数，如果 FS&lt;0.64FS&lt;0.64，不需要进行季节性差分，否则需要进行一次季节性差分。</p><p>对美国月度用电数据使用<code>nsdiffs()</code>函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">usmelec %&gt;% log() %&gt;% nsdiffs()</span><br><span class="line">#&gt; [1] 1</span><br><span class="line">usmelec %&gt;% log() %&gt;% diff(lag=12) %&gt;% ndiffs()</span><br><span class="line">#&gt; [1] 1</span><br></pre></td></tr></table></figure><p>由于<code>nsdiffs()</code>函数返回 1，（说明需要进行一次季节性差分），我们对季节差分后的数据运行<code>ndiffs()</code>函数。这些函数的运行结果说明我们应该进行一次季节性差分和一次一步差分。</p><p>ARIMA模型的优缺点，优点是模型十分简单，只需要内生变量而不需要借助其他外生变量。以最简单的模型 Y = aX + b 为例，X 是自变量，Y是因变量，a 和 b 都是外生变量，是由模型的外部因素决定的。</p><p>缺点：</p><ol><li>要求时序数据是稳定的（stationary），或者通过差分化（differencing）后是稳定的。</li><li>本质上只能捕捉线性关系，而不能捕捉非线性关系。</li></ol><p>那么要如何判断时序数据是稳定的呢？</p><p>一个时间序列的随机变量是稳定的，当且仅当它的统计特征都是独立于时间的（是关于时间的常量）。</p><ol><li>稳定的数据是没有趋势（trend），没有周期性（seasonality）的；即它的均值，在时间轴上拥有常量的振幅，并且它的方差，在时间轴上是趋于同一个稳定的值的。</li><li>可以用Dickey-Fuller Test 进行假设检验。</li></ol><p>ARIMA的参数与数学形式</p><p>ARIMA模型有三个参数p,d,q</p><ul><li>p – 代表预测模型中采用的时序数据本身的滞后数（lags），也叫做AR/Auto-Regressive项。</li><li>d – 代表时序数据需要进行几阶差分化才是稳定的，也叫Integrated项。</li><li>q – 代表预测模型中采用的预测误差的滞后数（lags），也叫MA/Moving Average项。</li></ul><p>差分 – 假设y表示t时刻的Y的差分</p><p>ARIMA的预测模型可以表示为：</p><p>Y的预测值 = 常量c and/or 一个或多个最近时间的Y的加权 and/or 一个或多个最近时间的预测误差。</p><p>假设p,q,d已知：</p><p>ARIMA用数学形式表示为:<br>$$<br>ytˆ=μ+ϕ1∗yt−1+…+ϕp∗yt−p+θ1∗et−1+…+θq∗et−q<br>其中,ϕ表示AR的系数，θ表示MA的系数<br>$$<br>ARIMA模型的几个特例</p><ol><li><p>ARIMA(0,1,0) = random walk:</p><p>当d=1,p 和 q 为0 时，叫做random walk，每一个时刻的Y，只与上一时刻的Y有关。<br>$$<br>Yˆt=μ+Yt−1<br>$$</p></li><li><p>ARIMA(1,0,0) = first-order autoregressive model:</p><p>当p=1,d=0,q=0,说明时序数据是稳定的和自相关的。一个时刻的Y值只与上一个时刻的Y值有关<br>$$<br>Yˆt=μ+ϕ1∗Yt−1.where, ϕ∈[−1,1],是一个斜率系数<br>$$</p></li><li><p>ARIMA(1,1,0) = differenced first-order autoregressive model:<br>p=1,d=1,q=0. 说明时序数据在一阶差分化之后是稳定的和自回归的。即一个时刻的差分（y）只与上一个时刻的差分有关。<br>$$<br>yˆt=μ+ϕ1∗yt−1结合一阶差分的定义，也可以表示为：Yˆt−Yt−1=μ+ϕ1∗(Yt−1−Yt−2)或者Yˆt=μ+Yt−1+ϕ1∗(Yt−1−Yt−2)<br>$$</p></li><li><p>ARIMA(0,1,1) = simple exponential smoothing with growth.<br> p=0, d=1 ,q=1.说明数据在一阶差分后市稳定的和移动平均的。即一个时刻的估计值的差分与上一个时刻的预测误差有关。<br>$$<br>yˆt=μ+α1∗et−1注意q=1的差分yt与p=1的差分yt的是不一样的其中，yˆt=Yˆt−Yˆt−1, et−1=Yt−1−Yˆt−1,设θ1=1−α1则也可以写成：Yˆt=μ+Yˆt−1+α1(Yt−1−Yˆt−1)=μ+Yt−1−θ1∗et−1<br>$$</p></li><li><p>ARIMA(2,1,2)<br>在通过上面的例子，可以很轻松的写出它的预测模型：<br>$$<br>yˆt=μ+ϕ1∗yt−1+ϕ2∗yt−2−θ1∗et−1−θ2∗et−2也可以写成:Yˆt=μ+ϕ1∗(Yt−1−Yt−2)+ϕ2∗(Yt−2−Yt−3)−θ1∗(Yt−1−Yˆt−1)−θ2∗(Yt−2−Yˆt−2)<br>$$</p></li><li><p>ARIMA(2,2,2)<br>$$<br>yˆt=μ+ϕ1∗yt−1+ϕ2∗yt−2−θ1∗et−1−θ2∗et−2Yˆt=μ+ϕ1∗(Yt−1−2Yt−2+Yt−3)+ϕ2∗(Yt−2−2Yt−3+Yt−4)−θ1∗(Yt−1−Yˆt−1)−θ2∗(Yt−2−Yˆt−2)<br>$$</p></li></ol><p>ARIMA建模基本步骤</p><ol><li>获取被观测系统时间序列数据；</li><li>对数据绘图，观测是否为平稳时间序列；对于非平稳时间序列要先进行d阶差分运算，化为平稳时间序列；</li><li>经过第二步处理，已经得到平稳时间序列。要对平稳时间序列分别求得其自相关系数ACF 和偏自相关系数PACF，通过对自相关图和偏自相关图的分析，得到最佳的阶层 p 和阶数 q</li><li>由以上得到的d、q、p，得到ARIMA模型。然后开始对得到的模型进行模型检验。</li></ol>]]></content:encoded>
      
      <comments>https://ningoy.github.io/2021/06/04/%E4%BD%BF%E7%94%A8ARIMA%E6%A8%A1%E5%9E%8B%E8%BF%9B%E8%A1%8C%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E5%88%86%E6%9E%90/#disqus_thread</comments>
    </item>
    
    <item>
      <title>处理数据常用的命令行工具</title>
      <link>https://ningoy.github.io/2020/03/27/%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</link>
      <guid>https://ningoy.github.io/2020/03/27/%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</guid>
      <pubDate>Fri, 27 Mar 2020 15:03:09 GMT</pubDate>
      <description>
      
        
        
          &lt;h4 id=&quot;head-amp-tail&quot;&gt;&lt;a href=&quot;#head-amp-tail&quot; class=&quot;headerlink&quot; title=&quot;head &amp;amp; tail&quot;&gt;&lt;/a&gt;head &amp;amp; tail&lt;/h4&gt;&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;he
        
      
      </description>
      
      <content:encoded><![CDATA[<h4 id="head-amp-tail"><a href="#head-amp-tail" class="headerlink" title="head &amp; tail"></a>head &amp; tail</h4><hr><ol><li><p><code>head</code> 默认打印出文件的前<code>10</code> 行，<code>tail</code> 默认打印出文件的最后<code>10</code> 行。</p></li><li><p>也可以使用<code>head -n 5 shakespeare_6.0.json</code> 或是 <code>head -5 shakespeare_6.0.json</code> 打印出前<code>5</code> 行。用<code>tail -n 5 shakespeare_6.0.json</code> 或 <code>tail -5 shakespeare_6.0.json</code> 打印出文件最后<code>5</code> 行。</p></li><li><p><code>head -n 10010 listings.csv | tail -10</code> 和 <code>tail -n +10001 listings.csv | head -n 10</code> 表示同一个意思，即是打印 <code>10001-10010</code> 行。</p></li><li><p><code>tail -f listings.csv</code> 这个命令既打印 <code>listings.csv</code> 文件的最后<code>10</code> 行，也能在<code>listings.csv</code> 文件行数增长时，继续打印新增的行。</p></li></ol><h4 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h4><hr><ol><li><p><code>head -n 10 listings.csv | tr &#39;,&#39; &#39;\t&#39;</code>  可以将<code>.csv</code> 文件中的<code>,</code> 分隔符换成<code>\t</code> 分隔符。</p></li><li><p><code>head -n 10 listings.csv | tr -d &#39;,&#39;</code> 可以将<code>.csv</code> 文件中的<code>,</code> 分隔符去掉。</p></li><li><p><code>head -n 10 listings.csv | tr &quot;[:lower:]&quot; &quot;[:upper:]&quot;</code> 可以将 <code>.csv</code> 文件中的小写字母换成大写字母，而这是通过<code>[:class:]</code> 做到的。</p><ul><li><code>[:alnum:]</code> 所有字母和数字</li></ul></li></ol><ul><li><code>[:alpha:]</code> 所有字母<ul><li><code>[:blank:]</code> 所有水平空白</li></ul></li><li><code>[:cntrl:]</code> 所有控制字符<ul><li><code>[:digit:]</code> 所有数字</li></ul></li><li><code>[:graph:]</code> 所有可打印字符，但不包括空格<ul><li><code>[:lower:]</code> 所有小写字母</li></ul></li><li><code>[:print:]</code> 所有可打印字符，包括空格<ul><li><code>[:punct:]</code> 所有标点符号</li></ul></li><li><code>[:space:]</code> 所有水平或垂直空白<ul><li><code>[:upper:]</code> 所有大写字母</li></ul></li><li><code>[:xdigit:]</code> 所有 16 进制数字</li></ul><h4 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h4><hr><ol><li><code>wc -l listings.csv</code> 打印 <code>listings.csv</code> 的行数。</li></ol><h4 id="sort-amp-uniq"><a href="#sort-amp-uniq" class="headerlink" title="sort &amp; uniq"></a>sort &amp; uniq</h4><hr><ol><li><p><code>uniq</code> 只作用于重复的相邻行，因此最好先对要处理的文件进行<code>sort</code> 。</p></li><li><p><code>head -500 listings.csv | awk -F &#39;,&#39; &#39;{print $6}&#39; | sort | uniq -c | sort -nr</code> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> sort 先排序，使得重复的行相邻便于uniq统计</span><br><span class="line"><span class="meta">#</span> 之后uniq -c 统计每一行重复的次数</span><br><span class="line"><span class="meta">#</span> 再通过sort -nr降序排列</span><br><span class="line"><span class="meta">#</span> 这样可以很快找到重复次数最多的一行</span><br><span class="line">    201 朝阳区 / Chaoyang</span><br><span class="line">     65 东城区</span><br><span class="line">     53 </span><br><span class="line">     34 海淀区</span><br><span class="line">     27 西城区</span><br><span class="line">     24 丰台区 / Fengtai</span><br><span class="line">     14 顺义区 / Shunyi</span><br><span class="line">     12 昌平区</span><br><span class="line">     12 怀柔区 / Huairou</span><br><span class="line">      6 通州区 / Tongzhou</span><br><span class="line">      5 密云县 / Miyun</span><br></pre></td></tr></table></figure></li><li><p><code>head -10 reviews.csv | tr &#39;,&#39; &#39; &#39; | sort -t&quot; &quot; -k2,2</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> -t 选项将" "指定为分隔符</span><br><span class="line"><span class="meta">#</span> -k 选项用来确定排序的键</span><br><span class="line"><span class="meta">#</span> -k2,2 意为 第2列为开始列 第2列为结束列</span><br><span class="line">44054 2010-08-25</span><br><span class="line">44054 2010-10-13</span><br><span class="line">44054 2011-08-11</span><br><span class="line">44054 2012-04-12</span><br><span class="line">44054 2012-08-30</span><br><span class="line">44054 2012-09-28</span><br><span class="line">44054 2012-10-04</span><br><span class="line">44054 2012-11-15</span><br><span class="line">44054 2013-03-08</span><br><span class="line">listing_id date</span><br></pre></td></tr></table></figure></li><li><p><code>head -n +100 reviews.csv | tail -10  | tr &#39;,&#39; &#39; &#39; | sort -t&quot; &quot; -k1n,1</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> -k1n,1 意为 第1列为开始列 第2列为结束列 同时第一列为数字 采用数字大小排序</span><br><span class="line">100213 2017-08-27</span><br><span class="line">100213 2017-10-08</span><br><span class="line">128496 2011-06-02</span><br><span class="line">128496 2011-06-05</span><br><span class="line">128496 2011-08-02</span><br><span class="line">128496 2011-08-26</span><br><span class="line">128496 2011-09-04</span><br><span class="line">128496 2011-09-07</span><br><span class="line">128496 2011-09-12</span><br><span class="line">128496 2011-09-19</span><br></pre></td></tr></table></figure></li></ol><h4 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h4><hr><ol><li><code>cut</code> 用于选择列，<code>cut -d&#39;,&#39; -f 1,3 listings.csv | head -10</code> 选择第1列和第3列。</li><li><code>head listings.csv | cut -d &#39;,&#39; -f 6-</code> 选择第6列以后的（包括第6列）所有列。</li></ol><h4 id="jq"><a href="#jq" class="headerlink" title="jq"></a>jq</h4><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">head -n 4 shakespeare_6.0.json</span><br><span class="line"></span><br><span class="line">&#123;"index":&#123;"_index":"shakespeare","_id":0&#125;&#125;</span><br><span class="line">&#123;"type":"act","line_id":1,"play_name":"Henry IV", "speech_number":"","line_number":"","speaker":"","text_entry":"ACT I"&#125;</span><br><span class="line">&#123;"index":&#123;"_index":"shakespeare","_id":1&#125;&#125;</span><br><span class="line">&#123;"type":"scene","line_id":2,"play_name":"Henry IV","speech_number":"","line_number":"","speaker":"","text_entry":"SCENE I. London. The palace."&#125;</span><br><span class="line"></span><br><span class="line">head -n 4 shakespeare_6.0.json | jq</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "index": &#123;</span><br><span class="line">    "_index": "shakespeare",</span><br><span class="line">    "_id": 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  "type": "act",</span><br><span class="line">  "line_id": 1,</span><br><span class="line">  "play_name": "Henry IV",</span><br><span class="line">  "speech_number": "",</span><br><span class="line">  "line_number": "",</span><br><span class="line">  "speaker": "",</span><br><span class="line">  "text_entry": "ACT I"</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  "index": &#123;</span><br><span class="line">    "_index": "shakespeare",</span><br><span class="line">    "_id": 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  "type": "scene",</span><br><span class="line">  "line_id": 2,</span><br><span class="line">  "play_name": "Henry IV",</span><br><span class="line">  "speech_number": "",</span><br><span class="line">  "line_number": "",</span><br><span class="line">  "speaker": "",</span><br><span class="line">  "text_entry": "SCENE I. London. The palace."</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">head -n 4 shakespeare_6.0.json | jq ".text_entry"</span><br><span class="line"></span><br><span class="line">null</span><br><span class="line">"ACT I"</span><br><span class="line">null</span><br><span class="line">"SCENE I. London. The palace."</span><br></pre></td></tr></table></figure><h4 id="sed-amp-awk"><a href="#sed-amp-awk" class="headerlink" title="sed &amp; awk"></a>sed &amp; awk</h4>]]></content:encoded>
      
      <comments>https://ningoy.github.io/2020/03/27/%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>561. Array Partition I</title>
      <link>https://ningoy.github.io/2018/05/05/561-Array-Partition-I/</link>
      <guid>https://ningoy.github.io/2018/05/05/561-Array-Partition-I/</guid>
      <pubDate>Sat, 05 May 2018 07:42:00 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;Given an array of &lt;strong&gt;2n&lt;/strong&gt; integers, your task is to group these integers into &lt;strong&gt;n&lt;/strong&gt; pairs of intege
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>Given an array of <strong>2n</strong> integers, your task is to group these integers into <strong>n</strong> pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible. </p></blockquote><p><strong>Example 1:</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,4,3,2]</span><br><span class="line"></span><br><span class="line">Output: 4</span><br><span class="line">Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> </p><ol><li><strong>n</strong> is a positive integer, which is in the range of [1, 10000].</li><li>All the integers in the array will be in the range of [-10000, 10000].</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20001</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)&#123;</span><br><span class="line">            count[i + <span class="number">10000</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span> odd = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count.length; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(count[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(odd)&#123;</span><br><span class="line">                    res += i - <span class="number">10000</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                odd = !odd;</span><br><span class="line">                count[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://ningoy.github.io/2018/05/05/561-Array-Partition-I/#disqus_thread</comments>
    </item>
    
    <item>
      <title>面试题2：实现Singleton模式</title>
      <link>https://ningoy.github.io/2018/03/24/%E9%9D%A2%E8%AF%95%E9%A2%982%EF%BC%9A%E5%AE%9E%E7%8E%B0Singleton%E6%A8%A1%E5%BC%8F/</link>
      <guid>https://ningoy.github.io/2018/03/24/%E9%9D%A2%E8%AF%95%E9%A2%982%EF%BC%9A%E5%AE%9E%E7%8E%B0Singleton%E6%A8%A1%E5%BC%8F/</guid>
      <pubDate>Sat, 24 Mar 2018 09:22:02 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;一、什么是单例模式&quot;&gt;&lt;a href=&quot;#一、什么是单例模式&quot; class=&quot;headerlink&quot; title=&quot;一、什么是单例模式&quot;&gt;&lt;/a&gt;一、什么是单例模式&lt;/h3&gt;&lt;p&gt;因程序需要，有时我们只需要某个类同时保留一个对象，不希望有更多对象，此时，我们则应该
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="一、什么是单例模式"><a href="#一、什么是单例模式" class="headerlink" title="一、什么是单例模式"></a>一、什么是单例模式</h3><p>因程序需要，有时我们只需要某个类同时保留一个对象，不希望有更多对象，此时，我们则应该考虑单例模式的设计。</p><h3 id="二、单例模式的特点"><a href="#二、单例模式的特点" class="headerlink" title="二、单例模式的特点"></a>二、单例模式的特点</h3><ol><li>单例模式只能有一个实例。</li><li>单例模式必须创建自己的唯一实例。</li><li>单例模式必须向其他对象提供这一实例。</li></ol><h3 id="三、单例模式-vs-静态类"><a href="#三、单例模式-vs-静态类" class="headerlink" title="三、单例模式 vs 静态类"></a>三、单例模式 vs 静态类</h3><ol><li>单例模式可以继承和被继承，方法可以被override，而静态方法不可以。</li><li>静态方法中产生的对象会在执行后被释放，进而被GC清理，不会一直存在于内存中。</li><li>静态类会在第一次运行时初始化，单例模式可以有其他的选择，即可以延迟加载。</li><li>基于2、3条，由于单例对象往往存在于DAO层，如果反复的初始化和释放，则会占用很多资源，而使用单例模式将其常驻于内存可以更加节约资源。</li><li>静态方法有更高的访问效率。</li><li>单例模式很容易被测试。</li></ol><p>几个关于静态类的误解：</p><ul><li>静态方法常驻内存而实例方法不是。<ul><li>实际上，特殊编写的实例方法可以常驻内存，而静态方法需要不断初始化和释放。</li></ul></li><li>静态方法在堆(heap)上，实例方法在栈(stack)上。<ul><li>实际上，都是加载到特殊的不可写的代码内存区域中</li></ul></li><li>静态类和单例模式情景的选择<ul><li>不需要维持任何状态，仅仅用于全局访问，此时更适合使用静态类。</li><li>需要维持一些特定的状态，此时更适合使用单例模式。</li></ul></li></ul><h3 id="四、单例模式的实现"><a href="#四、单例模式的实现" class="headerlink" title="四、单例模式的实现"></a>四、单例模式的实现</h3><ol><li><p>懒汉模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance=<span class="keyword">new</span> SingletonDemo();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，通过提供一个静态的对象<code>instance</code>，利用<code>private</code>权限的构造方法和<code>getInstance()</code>方法来给予访问者一个单例。</p><p>缺点是，没有考虑到线程安全，可能存在多个访问者同时访问，并同时构造了多个对象的问题。之所以叫做懒汉模式，主要是因为此种方法可以非常明显的lazy loading。</p><p>针对懒汉模式线程不安全的问题，我们自然想到了，在 <code>getInstance()</code> 方法前加锁，于是就有了第二种实现.</p></li><li><p>线程安全的懒汉模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance=<span class="keyword">new</span> SingletonDemo();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而并发其实是一种特殊情况，大多时候这个锁占用的额外资源都浪费了，这种打补丁方式写出来的结构效率很低。</p></li><li><p>饿汉模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo instance=<span class="keyword">new</span> SingletonDemo();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接在运行这个类的时候进行一次loading，之后直接访问。显然，这种方法没有起到lazy loading的效果，考虑到前面提到的和静态类的对比，这种方法只比静态类多了一个内存常驻而已。</p></li><li><p>静态类内部加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo instance=<span class="keyword">new</span> SingletonDemo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Singleton has loaded"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>枚举方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> SingletonDemo&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">otherMethods</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Something"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Effective Java作者Josh Bloch 提倡的方式，在我看来简直是来自神的写法。解决了以下三个问题：</p><p>(1)自由序列化。</p><p>(2)保证只有一个实例。</p><p>(3)线程安全。</p><p>如果我们想调用它的方法时，仅需要以下操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SingletonDemo.INSTANCE.otherMethods();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>双重校验锁法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SingletonDemo instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Singleton has loaded"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonDemo.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance=<span class="keyword">new</span> SingletonDemo();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我解释一下在并发时，双重校验锁法会有怎样的情景：</p><p>STEP 1. 线程A访问<code>getInstance()</code>方法，因为单例还没有实例化，所以进入了锁定块。</p><p>STEP 2. 线程B访问<code>getInstance()</code>方法，因为单例还没有实例化，得以访问接下来代码块，而接下来代码块已经被线程1锁定。</p><p>STEP 3. 线程A进入下一判断，因为单例还没有实例化，所以进行单例实例化，成功实例化后退出代码块，解除锁定。</p><p>STEP 4. 线程B进入接下来代码块，锁定线程，进入下一判断，因为已经实例化，退出代码块，解除锁定。</p><p>STEP 5. 线程A获取到了单例实例并返回，线程B没有获取到单例并返回Null。</p><p>理论上双重校验锁法是线程安全的，并且，这种方法实现了<code>lazyloading</code>。</p></li></ol>]]></content:encoded>
      
      <comments>https://ningoy.github.io/2018/03/24/%E9%9D%A2%E8%AF%95%E9%A2%982%EF%BC%9A%E5%AE%9E%E7%8E%B0Singleton%E6%A8%A1%E5%BC%8F/#disqus_thread</comments>
    </item>
    
    <item>
      <title>导入CSV文件到MySQL</title>
      <link>https://ningoy.github.io/2017/11/29/%E5%AF%BC%E5%85%A5CSV%E6%96%87%E4%BB%B6%E5%88%B0MySQL/</link>
      <guid>https://ningoy.github.io/2017/11/29/%E5%AF%BC%E5%85%A5CSV%E6%96%87%E4%BB%B6%E5%88%B0MySQL/</guid>
      <pubDate>Wed, 29 Nov 2017 11:37:44 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;从网上下载了一个&lt;a href=&quot;https://www.capitalbikeshare.com/system-data&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;公开数据集&lt;/a&gt;，想要用来做一点小实验。下载之后发现这是一个&lt;code&gt;.csv&lt;/
        
      
      </description>
      
      <content:encoded><![CDATA[<p>从网上下载了一个<a href="https://www.capitalbikeshare.com/system-data" target="_blank" rel="noopener">公开数据集</a>，想要用来做一点小实验。下载之后发现这是一个<code>.csv</code>格式的文件，里面大概有50多万条数据。那么下一步就是要把这些数据导入到数据库里。</p><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>用<code>python</code>的<code>pymysql</code>库来操作，先连接数据库，然后创建数据表，再构造出<code>sql</code>语句，把数据一条一条导进去。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'2016-Q1-Trips-History-Data.csv'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> csv_file:</span><br><span class="line">        spam_reader = csv.reader(csv_file, delimiter=<span class="string">','</span>)</span><br><span class="line">        headers = next(spam_reader)</span><br><span class="line">        db = pymysql.connect(<span class="string">'localhost'</span>, <span class="string">'username'</span>, <span class="string">'password'</span>, <span class="string">'tripshistorydata'</span>)</span><br><span class="line">        cursor = db.cursor()</span><br><span class="line">        cursor.execute(<span class="string">'DROP TABLE IF EXISTS temp;'</span>)</span><br><span class="line">        sql = <span class="string">"""</span></span><br><span class="line"><span class="string">            create table temp(</span></span><br><span class="line"><span class="string">            Duration int not null,</span></span><br><span class="line"><span class="string">            StartDate char(50) not null,</span></span><br><span class="line"><span class="string">            EndDate char(50) not null,</span></span><br><span class="line"><span class="string">            StartStationNumber int not null,</span></span><br><span class="line"><span class="string">            StartStation char(100) not null,</span></span><br><span class="line"><span class="string">            EndStationNumber int not null,</span></span><br><span class="line"><span class="string">            EndStation char(100) not null,</span></span><br><span class="line"><span class="string">            BikeNumber Char(50) not null,</span></span><br><span class="line"><span class="string">            MemberType char(50) not null);</span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line">        cursor.execute(sql)</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> spam_reader:</span><br><span class="line">            param = (</span><br><span class="line">                int(row[<span class="number">0</span>]), row[<span class="number">1</span>], row[<span class="number">2</span>], int(row[<span class="number">3</span>]), row[<span class="number">4</span>], int(row[<span class="number">5</span>]), row[<span class="number">6</span>], row[<span class="number">7</span>], row[<span class="number">8</span>]</span><br><span class="line">            )</span><br><span class="line">            sql = <span class="string">"""insert into temp(</span></span><br><span class="line"><span class="string">            Duration, StartDate, EndDate, StartStationNumber, StartStation, EndStationNumber, EndStation, BikeNumber, MemberType</span></span><br><span class="line"><span class="string">            ) values(%s, %s, %s, %s, %s, %s, %s, %s, %s);"""</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                cursor.execute(sql, param)</span><br><span class="line">                db.commit()</span><br><span class="line">                <span class="comment"># 记住这句话</span></span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                print(e)</span><br><span class="line">                db.rollback()</span><br><span class="line">        </span><br><span class="line">        db.close()</span><br><span class="line">    stop = time.time()</span><br><span class="line">    cost = stop - start</span><br><span class="line">    print(cost)</span><br></pre></td></tr></table></figure><p>但是吧，这么写实在太慢，睡了一个午觉还没导入完。那不行啊，那么有没有更快的办法呢？</p><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>答案当然是有的，为什么会那么慢，那是因为每一次<code>insert</code>的时候都会<code>commit</code>一次，这样当然会消耗很多时间。如果等所有数据都<code>insert</code>之后，只执行一次<code>commit</code>，当然就会快很多了。</p><p>然后嘞，还可以去<code>my.ini</code>里修改<code>innodb_flush_log_at_trx_commit</code>这么一个参数。</p><ul><li><p>当<code>innodb_flush_log_at_trx_commit=1</code>时，每次事务提交时MySQL都会把<code>log buffer</code>的数据写入<code>log file</code>，并且flush，该模式为系统默认。</p><blockquote><p>该模式是最安全的，但也是最慢的一种方式。在<code>mysqld</code>服务崩溃或者服务器主机<code>crash</code>的情况下，<code>binary log</code>只有可能丢失最多一个语句或者一个事务。</p></blockquote></li><li><p>当<code>innodb_flush_log_at_trx_commit=0</code>时，<code>log buffer</code>将每秒一次地写入<code>log file</code>中，并且<code>log file</code>的flush操作同时进行。该模式下在事务提交的时候，不会主动触发写入磁盘的操作。</p><blockquote><p>该模式速度最快，但不太安全，<code>mysqld</code>进程的崩溃会导致上一秒钟所有事务数据的丢失。</p></blockquote></li><li><p>当<code>innodb_flush_log_at_trx_commit=2</code>时，每次事务提交时MySQL都会把<code>log buffer</code>的数据写入<code>log file</code>，但是flush操作并不会同时进行。该模式下，MySQL会每秒执行一次 flush操作。</p><blockquote><p>该模式速度较快，也比<code>innodb_flush_log_at_trx_commit=0</code>安全，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数据才可能丢失。</p></blockquote></li></ul><p>综合起来，设置<code>innodb_flush_log_at_trx_commit=2</code>，然后重启MySQL服务器</p><p>看看这次需要多长的时间。</p><font color="red">264.5988073348999s</font><h3 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h3><p><strong>MySQL有一个高效的导入方法，那就是<code>load data infile</code>。 </strong></p><p>语法如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span>  [<span class="keyword">low_priority</span>] [<span class="keyword">local</span>] <span class="keyword">infile</span> <span class="string">'file_name txt'</span> [<span class="keyword">replace</span> | <span class="keyword">ignore</span>]</span><br><span class="line"><span class="keyword">into</span> <span class="keyword">table</span> tbl_name</span><br><span class="line">[<span class="keyword">fields</span></span><br><span class="line">[<span class="keyword">terminated</span> <span class="keyword">by</span><span class="string">'t'</span>]</span><br><span class="line">[<span class="keyword">OPTIONALLY</span>] <span class="keyword">enclosed</span> <span class="keyword">by</span> <span class="string">''</span>]</span><br><span class="line">[<span class="keyword">escaped</span> <span class="keyword">by</span><span class="string">'\' ]]</span></span><br><span class="line"><span class="string">[lines terminated by'</span>n<span class="string">']</span></span><br><span class="line"><span class="string">[ignore number lines]</span></span><br><span class="line"><span class="string">[(col_name,   )]</span></span><br></pre></td></tr></table></figure><p><code>load data infile</code>语句从一个文本文件中以很高的速度读入一个表中。使用这个命令之前，<code>mysqld</code>进程（服务）必须已经在运行。为了安全原因，当读取位于服务器上的文本文件时，文件必须处于数据库目录或可被所有人读取。另外，为了对服务器上文件使用<code>load data infile</code>，在服务器主机上你必须有<code>file</code>的权限。</p><ol><li>如果你指定关键词<code>low_priority</code>，那么MySQL将会等到没有其他人读这个表的时候，才把插入数据。</li><li>如果指定<code>local</code>关键词，则表明从客户主机读文件。如果没指定<code>local</code>，文件必须位于服务器上。</li><li><code>replace</code>和<code>ignore</code>关键词控制对现有的唯一键记录的重复的处理。如果你指定<code>replace</code>，新行将代替有相同的唯一键值的现有行。如果你指定<code>ignore</code>，跳过有唯一键的现有行的重复行的输入。如果你不指定任何一个选项，当找到重复键时，出现一个错误，并且文本文件的余下部分被忽略。</li><li>分隔符<ol><li><code>fields</code>关键字指定了文件记段的分割格式，如果用到这个关键字，MySQL剖析器希望看到至少有下面的一个选项：<ul><li><code>terminated by</code> 字段的分隔符</li><li><code>enclosed by</code> 字段括起字符</li><li><code>escaped by</code>  转义字符\</li></ul></li></ol></li></ol><p>代码如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">LOCAL</span> <span class="keyword">INFILE</span> <span class="string">'FileName'</span> <span class="keyword">REPLACE</span> </span><br><span class="line"><span class="keyword">INTO</span> <span class="keyword">TABLE</span> TableName</span><br><span class="line"><span class="keyword">FIELDS</span> </span><br><span class="line"><span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">','</span> </span><br><span class="line"><span class="keyword">OPTIONALLY</span> <span class="keyword">ENCLOSED</span> <span class="keyword">BY</span> <span class="string">''</span></span><br><span class="line"><span class="keyword">LINES</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">'\n'</span></span><br><span class="line"><span class="keyword">IGNORE</span> <span class="number">1</span> <span class="keyword">lines</span>;</span><br></pre></td></tr></table></figure><font color="red">64.813s</font>]]></content:encoded>
      
      <comments>https://ningoy.github.io/2017/11/29/%E5%AF%BC%E5%85%A5CSV%E6%96%87%E4%BB%B6%E5%88%B0MySQL/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
