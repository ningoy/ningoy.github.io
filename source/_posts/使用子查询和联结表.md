---
title: 使用子查询和联结表
date: 2017-10-20 19:15:34
tags: 
  - SQL
categories: 
  - 读书笔记
    - 计算机科学
      - 数据库
        - MySQL必知必会
---

# 使用子查询和联结表

## 使用子查询

### 利用子查询进行过滤

假设：

订单存储在两个表中。对于包含订单号、客户ID、订单日期的每个订单，`orders`表存储一行，各订单的物品存储在相关的`orderitems`表中。`orders` 表不存储客户信息。它只存储客户的ID。实际的客户信息存储在`customers`表中。

现在假如需要列出订购物品`TNT2` 的所有客户，应该怎样检索？

1. 检索包含物品`TNT2` 的所有订单的编号。
2. 检索具有前一步骤列出的订单编号的所有客户的ID。
3. 检索前一步骤返回的所有客户ID的客户信息。

上述每个步骤都可以单独作为一个查询来执行。可以把一条`SELECT` 语句返回的结果用于另一条`SELECT` 语句的`WHERE` 子句。

也可以使用**子查询**来把3个查询组合成一条语句。

```sql
select cust_name, cust_contact 
from customers 
where cust_id in (select cust_id 
                  from orders 
                  where order_num in (select order_num 
                                      from orderitems 
                                      where prod_id = 'TNT2'));
```

为了执行上述`SELECT` 语句，MySQL实际上必须执行3条`SELECT` 语句。最里面的子查询返回订单号列表，此列表用于其外面的子查询的`WHERE` 子句。外面的子查询返回客户ID列表，此客户ID列表用于最外层查询的`WHERE ` 子句。最外层查询确实返回所需的数据。

可见，在`WHERE` 子句中使用子查询能够编写出功能很强并且很灵活的SQL语句。对于能嵌套的子查询的数目没有限制，不过由于在实际使用时由于性能的限制，不能嵌套太多的子查询。

>**列必须匹配** 在`WHERE` 子句中使用子查询，应该保证`SELECT` 语句具有与`WHERE` 子句中相同数目的列。通常，子查询将返回单个列并且与单个列匹配，但如果需要也可以使用多个列。

### 作为计算字段使用子查询

使用子查询的另一方法是创建计算字段。假如需要显示`customers` 表中每个客户的订单总数。订单与相应的客户ID存储在`orders` 表中。

为了执行这个操作，遵循下面的步骤。

1. 从`customers` 表中检索客户列表。
2. 对于检索出的每个客户，统计其在`orders` 表中的订单数目。

为了对每个客户执行`COUNT(*)` 计算，应该把`COUNT(*)` 作为一个子查询。

```sql
select cust_name, 
       cust_state, 
       (select count(*) 
       from orders 
       where orders.cust_id = customers.cust_id) as orders
from customers 
order by cust_name;
```

这条`SELECT` 语句对`customers` 表中每个客户返回3列：`cust_name` 、`cust_state` 、和`orders` 。`orders` 是一个计算字段，它是由圆括号中的子查询建立的。该子查询对检索出的每个客户执行一次。在此例子中，该子查询执行了5次，因为检索出了5个客户。

子查询中的`WHERE` 子句和前面使用的`WHERE` 子句稍有不同，因为它使用了完全限定列名。下面的语句告诉SQL比较`orders` 表中的`cust_id` 与当前正从`customers` 表中检索出的`cust_id` ：

```sql
where orders.cust_id = customers.cust_id
```

**相关子查询 (correlated subquery)** 涉及外部查询的子查询。

这种类型的子查询称为**相关子查询** 。任何时候只要列名可能有多义性，就必须使用这种语法（表名和列名由一个句点分隔）。

> **逐渐增加子查询来建立查询 **
>
> 用子查询测试和调试查询很有技巧性，特别是在这些语句的复杂性不断增加的情况下更是如此。用子查询建立（和测试）查询的最可靠的方法是逐渐进行，这与MySQL处理它们的方法非常相同。首先，建立和测试最内层的查询。然后，用硬编码数据建立和测试外层查询，并且仅在确认它正常后才嵌入子查询。这时，再次测试它。对于要增加的每个查询，重复这些步骤。这样做仅给构造查询增加了一点点时间，但节省了以后（找出查询为什么不正常）的大量时间，并且极大地提高了查询一开始就正常工作的可能性。

## 联结表

## 联结

SQL最强大的功能之一，就是能在数据检索查询的执行中联结（join）表。

### 关系表

理解关系表的最好方法是来看一个现实世界中的例子。

假如有一个包含产品目录的数据库表，其中每种类比的物品占一行。对于每种物品要存储的信息包括产品描述和价格，以及生产该产品的供应商信息。

现在，假如有由同一供应商生产的多种物品，那么在何处存储供应商信息（如，供应商名、地址、联系方式等）呢？将这些数据与产品信息分开存储的理由如下。

+ 因为同一供应商生产的每个产品的供应商信息都是相同的，对每个产品重复此信息既浪费时间又浪费存储空间。
+ 如果供应商信息改变（例如，供应商搬家或电话号码变动），只需改动一次即可。
+ 如果有重复数据（即每种商品都储存供应商信息），很难保证每次输入该数据的方式都相同。不一致的数据在报表中很难利用。

关键是，相同数据出现多次绝不是一件好事，此因素是关系数据库设计的基础，关系表的设计就是要保证吧信息分解成多个表，一类数据一个表。各表通过某些常用的值（即关系设计中的**关系（relational）**互相关联）

在这个例子中可以建立两个表，一个存储供应商信息，另一个存储产品信息。`vendors` 表包含所有供应商信息，每个供应商占一行，每个供应商具有唯一的标识，此标识称为**主键（primary key）** ， 可以是供应商ID或任何其他唯一值。

`products`表只存储产品信息，它除了存储供应商ID（`vendors`表的主键）外不存储其他供应商信息。`vendors`表的主键又叫做`products`的外键，它将`vendors`表与`products`表相关联，利用供应商ID能从`vendors`表中找出相应供应商的详细信息。

> **外键（foreign key）** 外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。
>
> 这样做的好处如下：
>
> + 供应商信息不重复，从而不浪费时间和空间；
> + 如果供应商信息变动， 可以只更新`vendors`表中的单个记录，相关表中的数据不用改动；
> + 由于数据无重复，显然数据是一致的，这使得处理数据更简单。
>
> 总之，关系数据可以有效的存储和方便的处理。因此，关系数据库的可伸缩性远比非关系数据库要好。
>
> **可伸缩性（scale）** 能够适应不断增加的工作量而不失败。设计良好的数据库或应用程序称之为**可伸缩性好（scale well）**。 

### 为什么要使用联结

正如所述，分解数据为多个表能更有效地存储，更方便地处理，并且具有更大的可伸缩性。但这些好处是有代价的。

如果数据存储在多个表中，怎样用单条`select` 语句检索出数据？

答案是使用联结。简单的说，联结是一种机制，用来在一条`select`语句中关联表 ，因此称之为联结。使用特殊的语法，可以联结多个表返回同一组输出，联结在运行时关联表中正确的行。

> **维护引用完整性**  重要的是，要理解联结不是物理实体。换句话说，它在实际的数据库表中并不存在，联结由MySQL根据需要建立，它存在于查询的执行当中。
>
> 在使用关系表时，仅在关系列中插入合法的数据非常重要，回到这里的例子，如果在`products`表中插入非法供应商ID（即没有在`vendors`表中出现 ）的供应商生产的商品，则这些产品是不可访问的，因为它们没有关联到某个供应商。
>
> 为防止这种情况发生，可指示MySQL只允许在`products`表的供应商ID列中出现合法值（即出现在`vendors`表中的供应商）。这就是维护引用完整性，它是通过在表的定义中指定主键和外键来实现的。 

### 创建联结

联结的创建非常简单，规定要联结的所有表以及它们如何关联即可。请看下面的例子：

```sql
select vend_name, prod_name, prod_price
from vendors, products
where vendors.vend_id = products.vend_id
order by vend_name, prod_name;
```

> **完全限定列名** 在引用的列可能出现二义性时，必须使用完全限定列名（用一个点分隔的表名和列名）。如果引用一个没有用表名限制的具有二义性的列名，MySQL将返回错误。

### 内部联结

目前为止所用的联结成为**等值联结（equijoin）** ，它基于两个表之间的相等测试。这种联结也称为**内部联结** 。其实对于这种联结可以使用稍微不同的语法来明确指定联结的类型。下面的`select` 语句返回与前面例子完全相同的数据：

```sql
select vend_name, prod_name, prod_price
from vendors inner join products
on vendors.vend_id = products.vend_id;
```

